<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Function Reference · Rotations.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://JuliaGeometry.github.io/Rotations.jl/functionreference/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><script src="../../copy.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/custom.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="Rotations.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">Rotations.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../rotation_types/">Rotation Types</a></li><li><span class="tocitem">2D Rotations</span><ul><li><a class="tocitem" href="../2d_matrix/">Matrix</a></li><li><a class="tocitem" href="../2d_angle/">Angle</a></li></ul></li><li><span class="tocitem">3D Rotations</span><ul><li><a class="tocitem" href="../3d_matrix/">Matrix</a></li><li><a class="tocitem" href="../3d_euler/">Euler Angles</a></li><li><a class="tocitem" href="../3d_angleaxis/">Angle and Axis</a></li><li><a class="tocitem" href="../3d_quaternion/">Quaternion and Related Parameters</a></li></ul></li><li><span class="tocitem">Rotation Generators</span><ul><li><a class="tocitem" href="../rotation_generator_types/">Rotation Generator Types</a></li><li><a class="tocitem" href="../2d_rotation_generator/">2D Rotation Generators</a></li><li><a class="tocitem" href="../3d_rotation_generator/">3D Rotation Generators</a></li></ul></li><li><a class="tocitem" href="../general_dimensional_rotations/">General Dimensional Rotations</a></li><li><a class="tocitem" href="../functions/">Common Methods for Rotations</a></li><li><a class="tocitem" href="../visualizing/">Visualizing Rotations</a></li><li class="is-active"><a class="tocitem" href>Function Reference</a></li><li><a class="tocitem" href="../reference/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Function Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Function Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaGeometry/Rotations.jl/blob/master/docs/src/functionreference.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><article class="docstring"><header><a class="docstring-binding" id="Rotations.Angle2d" href="#Rotations.Angle2d"><code>Rotations.Angle2d</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Angle2d{T} &lt;: Rotation{2,T}
    theta::T
end</code></pre><p>A 2×2 rotation matrix parameterized by a 2D rotation by angle. Only the angle is stored inside the <code>Angle2d</code> type, values of <code>getindex</code> etc. are computed on the fly.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/Rotations.jl/blob/345d0d9b46dfca114c0adc1e17d43cf181a509ea/src/core_types.jl#L131-L139">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rotations.Angle2dGenerator" href="#Rotations.Angle2dGenerator"><code>Rotations.Angle2dGenerator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Angle2dGenerator{T} &lt;: RotationGenerator{2,T}
    v::T
end</code></pre><p>A 2×2 rotation generator matrix (i.e. skew-symmetric matrix). [ 0 -v   v  0 ]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/Rotations.jl/blob/345d0d9b46dfca114c0adc1e17d43cf181a509ea/src/rotation_generator.jl#L115-L123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rotations.AngleAxis" href="#Rotations.AngleAxis"><code>Rotations.AngleAxis</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct AngleAxis{T} &lt;: Rotation{3,T}
AngleAxis(Θ, x, y, z)</code></pre><p>A 3×3 rotation matrix parameterized by a 3D rotation by angle θ about an arbitrary axis <code>[x, y, z]</code>.</p><p>Note that the axis is not unique for θ = 0, and that this parameterization does not continuously map the neighbourhood of the identity rotation (and therefore might not be suitable for autodifferentation and optimization purposes).</p><p>Note: by default, the constructor will renormalize the input so that the axis has length 1 (x² + y² + z² = 1).</p><p>Renormalization can be skipped by passing <code>false</code> as an additional constructor argument, in which case the user provides the guarantee that the input arguments represent a normalized rotation axis. Operations on an <code>AngleAxis</code> with a rotation axis that does not have unit norm, created by skipping renormalization in this fashion, are not guaranteed to do anything sensible.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/Rotations.jl/blob/345d0d9b46dfca114c0adc1e17d43cf181a509ea/src/angleaxis_types.jl#L3-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rotations.ErrorMap" href="#Rotations.ErrorMap"><code>Rotations.ErrorMap</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ErrorMap</code></pre><p>A nonlinear mapping between the space of unit quaternions and three-dimensional rotation errors.</p><p>These mappings are extremely useful for converting from globally nonsingular 3D rotation representations such as <code>QuatRotation</code> or <code>RotMatrix3</code> to a three-parameter error that can be efficiently used in gradient-based optimization methods that optimize deviations about a current iterate using first or second-order information.</p><p><strong>Usage</strong></p><pre><code class="nohighlight hljs">errmap(v::AbstractVector)  # &quot;forward&quot; map from a 3D error to a `QuatRotation`
inv(errmap)(R::Rotation)   # &quot;inverse&quot; map from a rotation (via `QuatRotation`) to a 3D error</code></pre><p>where <code>errmap &lt;: ErrorMap</code></p><p><strong>Implemented Maps</strong></p><ul><li><code>CayleyMap</code>:  Uses <code>RodriguesParam</code> as the error representation (default).   Goes singular at 180° and does not have a sign ambiguity.</li><li><code>ExponentialMap</code>: Uses the canonical exponential map from Lie Group theory. Computationally   expensive to compute. Exhibits kinematic singularities.</li><li><code>MRPMap</code>: Uses a scaled <code>MRP</code> as the error representation. Singular at 360° but has   a sign ambiguity (with the &quot;shadow&quot; MRP set).</li><li><code>QuatVecMap</code>: Uses the vector part of the quaternions. Cheapest map to compute, but   goes singular at 180° and suffers from sign ambiguity.</li><li><code>IdentityMap</code>: Maps values through directly. Only works with three-parameter rotation   representations with the following methods: <code>R(::SVector{3})</code> and <code>SVector(::R)::SVector{3}</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/Rotations.jl/blob/345d0d9b46dfca114c0adc1e17d43cf181a509ea/src/error_maps.jl#L2-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rotations.InvErrorMap" href="#Rotations.InvErrorMap"><code>Rotations.InvErrorMap</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">InvErrorMap</code></pre><p>The nonlinear mapping from unit quaternions to a three-dimensional error state. Obtained by inverting an <code>ErrorMap</code>, i.e.</p><pre><code class="nohighlight hljs">InvCayleyMap() = inv(CayleyMap())</code></pre><p><strong>Usage</strong></p><pre><code class="nohighlight hljs">imap(R::Rotation)             # &quot;inverse&quot; map from a rotation to a 3D error
inv(imap)(v::AbstractVector)  # &quot;forward&quot; map from a 3D error to a `QuatRotation`</code></pre><p>where <code>imap &lt;: InvErrorMap</code>.</p><p>See <code>ErrorMap</code> for documentation on the implemented maps.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/Rotations.jl/blob/345d0d9b46dfca114c0adc1e17d43cf181a509ea/src/error_maps.jl#L38-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rotations.MRP" href="#Rotations.MRP"><code>Rotations.MRP</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MRP{T} &lt;: Rotation</code></pre><p>Modified Rodrigues Parameter. Is a 3D parameterization of attitude, and is a sterographic projection of the 4D unit sphere onto the plane tangent to the negative real pole. They have a singularity at θ = ±360°.</p><p><strong>Constructors</strong></p><p>MRP(x, y, z) MRP(r::AbstractVector)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/Rotations.jl/blob/345d0d9b46dfca114c0adc1e17d43cf181a509ea/src/mrps.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rotations.QuatRotation" href="#Rotations.QuatRotation"><code>Rotations.QuatRotation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">QuatRotation{T} &lt;: Rotation</code></pre><p>4-parameter attitute representation that is singularity-free. Quaternions with unit norm represent a double-cover of SO(3). The <code>QuatRotation</code> does NOT strictly enforce the unit norm constraint, but certain methods will assume you have a unit quaternion. Follows the Hamilton convention for quaternions.</p><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">QuatRotation(w,x,y,z)
QuatRotation(q::AbstractVector)</code></pre><p>where <code>w</code> is the scalar (real) part, <code>x</code>,<code>y</code>, and <code>z</code> are the vector (imaginary) part, and <code>q = [w,x,y,z]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/Rotations.jl/blob/345d0d9b46dfca114c0adc1e17d43cf181a509ea/src/unitquaternion.jl#L3-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rotations.RodriguesParam" href="#Rotations.RodriguesParam"><code>Rotations.RodriguesParam</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RodriguesParam{T}</code></pre><p>Rodrigues parameters are a three-dimensional parameterization of rotations. They have a singularity at 180° but do not inherit the sign ambiguities of quaternions or MRPs</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/Rotations.jl/blob/345d0d9b46dfca114c0adc1e17d43cf181a509ea/src/rodrigues_params.jl#L2-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rotations.RotMatrix" href="#Rotations.RotMatrix"><code>Rotations.RotMatrix</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct RotMatrix{N,T} &lt;: Rotation{N,T}</code></pre><p>A statically-sized, N×N unitary (orthogonal) matrix.</p><p>Note: the orthonormality of the input matrix is <em>not</em> checked by the constructor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/Rotations.jl/blob/345d0d9b46dfca114c0adc1e17d43cf181a509ea/src/core_types.jl#L62-L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rotations.RotMatrixGenerator" href="#Rotations.RotMatrixGenerator"><code>Rotations.RotMatrixGenerator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct RotMatrixGenerator{N,T} &lt;: RotationGenerator{N,T}</code></pre><p>A statically-sized, N×N skew-symmetric matrix.</p><p>Note: the skew-symmetricity of the input matrix is <em>not</em> checked by the constructor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/Rotations.jl/blob/345d0d9b46dfca114c0adc1e17d43cf181a509ea/src/rotation_generator.jl#L42-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rotations.RotX" href="#Rotations.RotX"><code>Rotations.RotX</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct RotX{T} &lt;: Rotation{3,T}
RotX(theta)</code></pre><p>A 3×3 rotation matrix which represents a rotation by <code>theta</code> about the X axis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/Rotations.jl/blob/345d0d9b46dfca114c0adc1e17d43cf181a509ea/src/euler_types.jl#L41-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rotations.RotXY" href="#Rotations.RotXY"><code>Rotations.RotXY</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct RotXY{T} &lt;: Rotation{3,T}
RotXY(theta_x, theta_y)</code></pre><p>A 3×3 rotation matrix which represents a rotation by <code>theta_y</code> about the Y axis, followed by a rotation by <code>theta_x</code> about the X axis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/Rotations.jl/blob/345d0d9b46dfca114c0adc1e17d43cf181a509ea/src/euler_types.jl#L254-L260">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rotations.RotXYX" href="#Rotations.RotXYX"><code>Rotations.RotXYX</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct RotXYX{T} &lt;: Rotation{3,T}
RotXYX(theta1, theta2, theta3)</code></pre><p>A 3×3 rotation matrix parameterized by the &quot;proper&quot; XYX Euler angle convention, consisting of first a rotation about the X axis by <code>theta3</code>, followed by a rotation about the Y axis by <code>theta2</code>, and finally a rotation about the X axis by <code>theta1</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/Rotations.jl/blob/345d0d9b46dfca114c0adc1e17d43cf181a509ea/src/euler_types.jl#L562-L570">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rotations.RotXYZ" href="#Rotations.RotXYZ"><code>Rotations.RotXYZ</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct RotXYZ{T} &lt;: Rotation{3,T}
RotXYZ(theta1, theta2, theta3)
RotXYZ(roll=r, pitch=p, yaw=y)</code></pre><p>A 3×3 rotation matrix parameterized by the &quot;Tait-Bryant&quot; XYZ Euler angle convention, consisting of first a rotation about the Z axis by <code>theta3</code>, followed by a rotation about the Y axis by <code>theta2</code>, and finally a rotation about the X axis by <code>theta1</code>.</p><p>The keyword argument form applies roll, pitch and yaw to the X, Y and Z axes respectively, in XYZ order. (Because it is a right-handed coordinate system, note that positive pitch is heading in the negative Z axis).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/Rotations.jl/blob/345d0d9b46dfca114c0adc1e17d43cf181a509ea/src/euler_types.jl#L871-L884">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rotations.RotXZ" href="#Rotations.RotXZ"><code>Rotations.RotXZ</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct RotXZ{T} &lt;: Rotation{3,T}
RotXZ(theta_x, theta_z)</code></pre><p>A 3×3 rotation matrix which represents a rotation by <code>theta_z</code> about the Z axis, followed by a rotation by <code>theta_x</code> about the X axis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/Rotations.jl/blob/345d0d9b46dfca114c0adc1e17d43cf181a509ea/src/euler_types.jl#L326-L332">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rotations.RotXZX" href="#Rotations.RotXZX"><code>Rotations.RotXZX</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct RotXZX{T} &lt;: Rotation{3,T}
RotXZX(theta1, theta2, theta3)</code></pre><p>A 3×3 rotation matrix parameterized by the &quot;proper&quot; XZX Euler angle convention, consisting of first a rotation about the X axis by <code>theta3</code>, followed by a rotation about the Z axis by <code>theta2</code>, and finally a rotation about the X axis by <code>theta1</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/Rotations.jl/blob/345d0d9b46dfca114c0adc1e17d43cf181a509ea/src/euler_types.jl#L613-L621">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rotations.RotXZY" href="#Rotations.RotXZY"><code>Rotations.RotXZY</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct RotXZY{T} &lt;: Rotation{3,T}
RotXZY(theta1, theta2, theta3)
RotXZY(roll=r, pitch=p, yaw=y)</code></pre><p>A 3×3 rotation matrix parameterized by the &quot;Tait-Bryant&quot; XZY Euler angle convention, consisting of first a rotation about the Y axis by <code>theta3</code>, followed by a rotation about the Z axis by <code>theta2</code>, and finally a rotation about the X axis by <code>theta1</code>.</p><p>The keyword argument form applies roll, pitch and yaw to the X, Y and Z axes respectively, in XZY order. (Because it is a right-handed coordinate system, note that positive pitch is heading in the negative Z axis).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/Rotations.jl/blob/345d0d9b46dfca114c0adc1e17d43cf181a509ea/src/euler_types.jl#L987-L1000">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rotations.RotY" href="#Rotations.RotY"><code>Rotations.RotY</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct RotY{T} &lt;: Rotation{3,T}
RotY(theta)</code></pre><p>A 3×3 rotation matrix which represents a rotation by <code>theta</code> about the Y axis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/Rotations.jl/blob/345d0d9b46dfca114c0adc1e17d43cf181a509ea/src/euler_types.jl#L92-L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rotations.RotYX" href="#Rotations.RotYX"><code>Rotations.RotYX</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct RotYX{T} &lt;: Rotation{3,T}
RotYX(theta_y, theta_x)</code></pre><p>A 3×3 rotation matrix which represents a rotation by <code>theta_x</code> about the X axis, followed by a rotation by <code>theta_y</code> about the Y axis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/Rotations.jl/blob/345d0d9b46dfca114c0adc1e17d43cf181a509ea/src/euler_types.jl#L290-L296">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rotations.RotYXY" href="#Rotations.RotYXY"><code>Rotations.RotYXY</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct RotYXY{T} &lt;: Rotation{3,T}
RotYXY(theta1, theta2, theta3)</code></pre><p>A 3×3 rotation matrix parameterized by the &quot;proper&quot; YXY Euler angle convention, consisting of first a rotation about the Y axis by <code>theta3</code>, followed by a rotation about the X axis by <code>theta2</code>, and finally a rotation about the Y axis by <code>theta1</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/Rotations.jl/blob/345d0d9b46dfca114c0adc1e17d43cf181a509ea/src/euler_types.jl#L664-L672">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rotations.RotYXZ" href="#Rotations.RotYXZ"><code>Rotations.RotYXZ</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct RotYXZ{T} &lt;: Rotation{3,T}
RotYXZ(theta1, theta2, theta3)
RotYXZ(roll=r, pitch=p, yaw=y)</code></pre><p>A 3×3 rotation matrix parameterized by the &quot;Tait-Bryant&quot; YXZ Euler angle convention, consisting of first a rotation about the Z axis by <code>theta3</code>, followed by a rotation about the X axis by <code>theta2</code>, and finally a rotation about the Y axis by <code>theta1</code>.</p><p>The keyword argument form applies roll, pitch and yaw to the X, Y and Z axes respectively, in YXZ order. (Because it is a right-handed coordinate system, note that positive pitch is heading in the negative Z axis).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/Rotations.jl/blob/345d0d9b46dfca114c0adc1e17d43cf181a509ea/src/euler_types.jl#L1103-L1116">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rotations.RotYZ" href="#Rotations.RotYZ"><code>Rotations.RotYZ</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct RotYZ{T} &lt;: Rotation{3,T}
RotYZ(theta_y, theta_z)</code></pre><p>A 3×3 rotation matrix which represents a rotation by <code>theta_z</code> about the Z axis, followed by a rotation by <code>theta_y</code> about the Y axis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/Rotations.jl/blob/345d0d9b46dfca114c0adc1e17d43cf181a509ea/src/euler_types.jl#L434-L440">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rotations.RotYZX" href="#Rotations.RotYZX"><code>Rotations.RotYZX</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct RotYZX{T} &lt;: Rotation{3,T}
RotYZX(theta1, theta2, theta3)
RotYZX(roll=r, pitch=p, yaw=y)</code></pre><p>A 3×3 rotation matrix parameterized by the &quot;Tait-Bryant&quot; YZX Euler angle convention, consisting of first a rotation about the X axis by <code>theta3</code>, followed by a rotation about the Z axis by <code>theta2</code>, and finally a rotation about the Y axis by <code>theta1</code>.</p><p>The keyword argument form applies roll, pitch and yaw to the X, Y and Z axes respectively, in YZX order. (Because it is a right-handed coordinate system, note that positive pitch is heading in the negative Z axis).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/Rotations.jl/blob/345d0d9b46dfca114c0adc1e17d43cf181a509ea/src/euler_types.jl#L1045-L1058">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rotations.RotYZY" href="#Rotations.RotYZY"><code>Rotations.RotYZY</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct RotYZY{T} &lt;: Rotation{3,T}
RotYZY(theta1, theta2, theta3)</code></pre><p>A 3×3 rotation matrix parameterized by the &quot;proper&quot; YXY Euler angle convention, consisting of first a rotation about the Y axis by <code>theta3</code>, followed by a rotation about the Z axis by <code>theta2</code>, and finally a rotation about the Y axis by <code>theta1</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/Rotations.jl/blob/345d0d9b46dfca114c0adc1e17d43cf181a509ea/src/euler_types.jl#L715-L723">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rotations.RotZ" href="#Rotations.RotZ"><code>Rotations.RotZ</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct RotZ{T} &lt;: Rotation{3,T}
RotZ(theta)</code></pre><p>A 3×3 rotation matrix which represents a rotation by <code>theta</code> about the Z axis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/Rotations.jl/blob/345d0d9b46dfca114c0adc1e17d43cf181a509ea/src/euler_types.jl#L147-L152">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rotations.RotZX" href="#Rotations.RotZX"><code>Rotations.RotZX</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct RotZX{T} &lt;: Rotation{3,T}
RotZX(theta_z, theta_x)</code></pre><p>A 3×3 rotation matrix which represents a rotation by <code>theta_x</code> about the X axis, followed by a rotation by <code>theta_z</code> about the Z axis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/Rotations.jl/blob/345d0d9b46dfca114c0adc1e17d43cf181a509ea/src/euler_types.jl#L362-L368">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rotations.RotZXY" href="#Rotations.RotZXY"><code>Rotations.RotZXY</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct RotZXY{T} &lt;: Rotation{3,T}
RotZXY(theta1, theta2, theta3)
RotZXY(roll=r, pitch=p, yaw=y)</code></pre><p>A 3×3 rotation matrix parameterized by the &quot;Tait-Bryant&quot; ZXY Euler angle convention, consisting of first a rotation about the Y axis by <code>theta3</code>, followed by a rotation about the X axis by <code>theta2</code>, and finally a rotation about the Z axis by <code>theta1</code>.</p><p>The keyword argument form applies roll, pitch and yaw to the X, Y and Z axes respectively, in ZXY order. (Because it is a right-handed coordinate system, note that positive pitch is heading in the negative Z axis).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/Rotations.jl/blob/345d0d9b46dfca114c0adc1e17d43cf181a509ea/src/euler_types.jl#L1161-L1174">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rotations.RotZXZ" href="#Rotations.RotZXZ"><code>Rotations.RotZXZ</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct RotZXZ{T} &lt;: Rotation{3,T}
RotZXZ(theta1, theta2, theta3)</code></pre><p>A 3×3 rotation matrix parameterized by the &quot;proper&quot; ZXZ Euler angle convention, consisting of first a rotation about the Z axis by <code>theta3</code>, followed by a rotation about the X axis by <code>theta2</code>, and finally a rotation about the Z axis by <code>theta1</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/Rotations.jl/blob/345d0d9b46dfca114c0adc1e17d43cf181a509ea/src/euler_types.jl#L766-L774">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rotations.RotZY" href="#Rotations.RotZY"><code>Rotations.RotZY</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct RotZY{T} &lt;: Rotation{3,T}
RotZY(theta_z, theta_y)</code></pre><p>A 3×3 rotation matrix which represents a rotation by <code>theta_y</code> about the Y axis, followed by a rotation by <code>theta_z</code> about the Z axis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/Rotations.jl/blob/345d0d9b46dfca114c0adc1e17d43cf181a509ea/src/euler_types.jl#L398-L404">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rotations.RotZYX" href="#Rotations.RotZYX"><code>Rotations.RotZYX</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct RotZYX{T} &lt;: Rotation{3,T}
RotZYX(theta1, theta2, theta3)
RotZYX(roll=r, pitch=p, yaw=y)</code></pre><p>A 3×3 rotation matrix parameterized by the &quot;Tait-Bryant&quot; ZYX Euler angle convention, consisting of first a rotation about the X axis by <code>theta3</code>, followed by a rotation about the Y axis by <code>theta2</code>, and finally a rotation about the Z axis by <code>theta1</code>.</p><p>The keyword argument form applies roll, pitch and yaw to the X, Y and Z axes respectively, in ZYX order. (Because it is a right-handed coordinate system, note that positive pitch is heading in the negative Z axis).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/Rotations.jl/blob/345d0d9b46dfca114c0adc1e17d43cf181a509ea/src/euler_types.jl#L929-L942">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rotations.RotZYZ" href="#Rotations.RotZYZ"><code>Rotations.RotZYZ</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct RotZYZ{T} &lt;: Rotation{3,T}
RotZYZ(theta1, theta2, theta3)</code></pre><p>A 3×3 rotation matrix parameterized by the &quot;proper&quot; ZXZ Euler angle convention, consisting of first a rotation about the Z axis by <code>theta3</code>, followed by a rotation about the Y axis by <code>theta2</code>, and finally a rotation about the Z axis by <code>theta1</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/Rotations.jl/blob/345d0d9b46dfca114c0adc1e17d43cf181a509ea/src/euler_types.jl#L817-L825">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rotations.Rotation" href="#Rotations.Rotation"><code>Rotations.Rotation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type Rotation{N,T} &lt;: StaticMatrix{N,N,T}</code></pre><p>An abstract type representing <code>N</code>-dimensional rotations. More abstractly, they represent unitary (orthogonal) <code>N</code>×<code>N</code> matrices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/Rotations.jl/blob/345d0d9b46dfca114c0adc1e17d43cf181a509ea/src/core_types.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rotations.RotationError" href="#Rotations.RotationError"><code>Rotations.RotationError</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RotationError{T&lt;:Real, D&lt;:ErrorMap} &lt;: StaticVector{3,T}</code></pre><p>A three-parameter rotation error, converted to/from a <code>QuatRotation</code> using the <code>ErrorMap</code> <code>D</code>.</p><p><strong>Usage</strong></p><p>A <code>RotationError</code> is typically created using one of the following methods</p><pre><code class="nohighlight hljs">rotation_error(R1::Rotation, R2::Rotation, error_map::ErrorMap)
R1 ⊖ R2</code></pre><p>which compute the difference between the rotations <code>R1</code> and <code>R2</code> and convert the result to a 3D rotation error using <code>error_map</code>.</p><p>The error can be &quot;added&quot; back to a rotation using the inverse operation:</p><pre><code class="nohighlight hljs">add_error(R1::Rotation, e::RotationError)
R1::Rotation ⊕ e::RotationError</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/Rotations.jl/blob/345d0d9b46dfca114c0adc1e17d43cf181a509ea/src/rotation_error.jl#L2-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rotations.RotationGenerator" href="#Rotations.RotationGenerator"><code>Rotations.RotationGenerator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type RotationGenerator{N,T} &lt;: StaticMatrix{N,N,T}</code></pre><p>An abstract type representing <code>N</code>-dimensional rotation generator. More abstractly, they represent skew-symmetric real <code>N</code>×<code>N</code> matrices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/Rotations.jl/blob/345d0d9b46dfca114c0adc1e17d43cf181a509ea/src/rotation_generator.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rotations.RotationVec" href="#Rotations.RotationVec"><code>Rotations.RotationVec</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct RotationVec{T} &lt;: Rotation{3,T}
RotationVec(sx, sy, sz)</code></pre><p>Rodrigues vector parameterization of a 3×3 rotation matrix. The direction of the vector [sx, sy, sz] defines the axis of rotation, and the rotation angle is given by its norm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/Rotations.jl/blob/345d0d9b46dfca114c0adc1e17d43cf181a509ea/src/angleaxis_types.jl#L145-L152">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rotations.RotationVecGenerator" href="#Rotations.RotationVecGenerator"><code>Rotations.RotationVecGenerator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct RotationVecGenerator{T} &lt;: RotationGenerator{2,T}
    x::T
    y::T
    z::T
end</code></pre><p>A 3×3 rotation generator matrix (i.e. skew-symmetric matrix). [ 0 -z  y   z  0 -x  -y  x  0]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/Rotations.jl/blob/345d0d9b46dfca114c0adc1e17d43cf181a509ea/src/rotation_generator.jl#L161-L172">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:*-Tuple{QuatRotation, QuatRotation}" href="#Base.:*-Tuple{QuatRotation, QuatRotation}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(*)(q::QuatRotation, w::QuatRotation)</code></pre><p>Quternion Composition</p><p>Equivalent to</p><pre><code class="language-julia hljs">lmult(q) * SVector(w)
rmult(w) * SVector(q)</code></pre><p>Sets the output mapping equal to the mapping of <code>w</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/Rotations.jl/blob/345d0d9b46dfca114c0adc1e17d43cf181a509ea/src/unitquaternion.jl#L303-L315">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:*-Tuple{QuatRotation, StaticArrays.StaticVector}" href="#Base.:*-Tuple{QuatRotation, StaticArrays.StaticVector}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(*)(q::QuatRotation, r::StaticVector)</code></pre><p>Rotate a vector</p><p>Equivalent to <code>hmat()&#39; lmult(q) * rmult(q)&#39; hmat() * r</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/Rotations.jl/blob/345d0d9b46dfca114c0adc1e17d43cf181a509ea/src/unitquaternion.jl#L320-L326">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rotations.add_error-Tuple{Rotation, Rotations.RotationError}" href="#Rotations.add_error-Tuple{Rotation, Rotations.RotationError}"><code>Rotations.add_error</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_error(R1::Rotation, e::RotationError)</code></pre><p>&quot;Adds&quot; the rotation error <code>e</code> to the rotation <code>R1</code> by converting <code>e</code> to a quaternion via its <code>ErrorMap</code> and then composing with <code>R1</code>.</p><p>Equivalent to</p><pre><code class="nohighlight hljs">R1 ⊕ e</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/Rotations.jl/blob/345d0d9b46dfca114c0adc1e17d43cf181a509ea/src/rotation_error.jl#L71-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rotations.hmat-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T" href="#Rotations.hmat-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>Rotations.hmat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hmat()
hmat(r::AbstractVector)</code></pre><p><code>hmat()*r</code> or <code>hmat(r)</code> converts <code>r</code> into a pure quaternion, where <code>r</code> is 3-dimensional.</p><p><code>hmat() == vmat()&#39;</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/Rotations.jl/blob/345d0d9b46dfca114c0adc1e17d43cf181a509ea/src/unitquaternion.jl#L466-L473">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rotations.isrotation" href="#Rotations.isrotation"><code>Rotations.isrotation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">isrotation(r)
isrotation(r, tol)</code></pre><p>Check whether <code>r</code> is a rotation matrix, where <code>r * r&#39;</code> is within <code>tol</code> of the identity matrix (using the Frobenius norm). <code>tol</code> defaults to <code>1000 * eps(float(eltype(r)))</code> or <code>zero(T)</code> for integer <code>T</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/Rotations.jl/blob/345d0d9b46dfca114c0adc1e17d43cf181a509ea/src/core_types.jl#L198-L205">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rotations.isrotationgenerator" href="#Rotations.isrotationgenerator"><code>Rotations.isrotationgenerator</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">isrotationgenerator(r)</code></pre><p>Check whether <code>r</code> is a rotation generator matrix (skew-symmetric matrix).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/Rotations.jl/blob/345d0d9b46dfca114c0adc1e17d43cf181a509ea/src/rotation_generator.jl#L250-L254">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rotations.jacobian" href="#Rotations.jacobian"><code>Rotations.jacobian</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">jacobian(::InvErrorMap, q::QuatRotation)</code></pre><p>Jacobian of the inverse quaternion map, returning a 3×4 matrix. For all maps: <code>jacobian(::InvErrorMap, QuatRotation(I)) = [0 I] = Hmat()&#39;</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/Rotations.jl/blob/345d0d9b46dfca114c0adc1e17d43cf181a509ea/src/error_maps.jl#L182-L187">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rotations.jacobian" href="#Rotations.jacobian"><code>Rotations.jacobian</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">jacobian(::ErrorMap, ϕ)</code></pre><p>Jacobian of the quaternion map that takes a three-dimensional vector <code>ϕ</code> and returns a     unit quaternion. Returns a 4x3 Static Matrix</p><p>For all the maps (except the <code>IdentityMap</code>) <code>jacobian(::ErrorMap, zeros(3)) = [0; I] = Hmat()&#39;</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/Rotations.jl/blob/345d0d9b46dfca114c0adc1e17d43cf181a509ea/src/error_maps.jl#L110-L119">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rotations.jacobian-Tuple{Type{RotMatrix}, QuatRotation}" href="#Rotations.jacobian-Tuple{Type{RotMatrix}, QuatRotation}"><code>Rotations.jacobian</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">jacobian(::Type{output_param}, R::input_param)</code></pre><p>Returns the jacobian for transforming from the input rotation parameterization to the output parameterization, centered at the value of R.</p><pre><code class="nohighlight hljs">jacobian(R::rotation_type, X::AbstractVector)</code></pre><p>Returns the jacobian for rotating the vector X by R.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/Rotations.jl/blob/345d0d9b46dfca114c0adc1e17d43cf181a509ea/src/derivatives.jl#L25-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rotations.kinematics-Union{Tuple{Q}, Tuple{Q, AbstractVector}} where Q&lt;:QuatRotation" href="#Rotations.kinematics-Union{Tuple{Q}, Tuple{Q, AbstractVector}} where Q&lt;:QuatRotation"><code>Rotations.kinematics</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">kinematics(R::Rotation{3}, ω::AbstractVector)</code></pre><p>The time derivative of the rotation R, according to the definition</p><p><span>$Ṙ = \lim_{Δt → 0} \frac{R(t + Δt) - R(t)}{Δt}$</span></p><p>where <code>ω</code> is the angular velocity. This is equivalent to</p><p><span>$Ṙ = \lim_{Δt → 0} \frac{R δR - R}{Δt}$</span></p><p>where <span>$δR$</span> is some small rotation, parameterized by a small rotation <span>$δθ$</span> about an axis <span>$r$</span>, such that <span>$lim_{Δt → 0} \frac{δθ r}{Δt} = ω$</span></p><p>The kinematics are extremely useful when computing the dynamics of rigid bodies, since <code>Ṙ = kinematics(R,ω)</code> is the first-order ODE for the evolution of the attitude dynamics.</p><p>See &quot;Fundamentals of Spacecraft Attitude Determination and Control&quot; by Markley and Crassidis Sections 3.1-3.2 for more details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/Rotations.jl/blob/345d0d9b46dfca114c0adc1e17d43cf181a509ea/src/unitquaternion.jl#L355-L374">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rotations.lmult-Tuple{QuatRotation}" href="#Rotations.lmult-Tuple{QuatRotation}"><code>Rotations.lmult</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">lmult(q::QuatRotation)
lmult(q::StaticVector{4})</code></pre><p><code>lmult(q2)*params(q1)</code> returns a vector equivalent to <code>q2*q1</code> (quaternion composition)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/Rotations.jl/blob/345d0d9b46dfca114c0adc1e17d43cf181a509ea/src/unitquaternion.jl#L380-L385">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rotations.nearest_rotation-Union{Tuple{StaticArrays.StaticMatrix{N, N}}, Tuple{N}} where N" href="#Rotations.nearest_rotation-Union{Tuple{StaticArrays.StaticMatrix{N, N}}, Tuple{N}} where N"><code>Rotations.nearest_rotation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nearest_rotation(M) -&gt; RotMatrix</code></pre><p>Get the nearest special orthonormal matrix from given matrix <code>M</code>. See <a href="https://en.wikipedia.org/wiki/Wahba%27s_problem">Wahba&#39;s problem</a> for more information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/Rotations.jl/blob/345d0d9b46dfca114c0adc1e17d43cf181a509ea/src/core_types.jl#L229-L234">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rotations.params-Tuple{QuatRotation}" href="#Rotations.params-Tuple{QuatRotation}"><code>Rotations.params</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">params(R::Rotation)</code></pre><p>Return an <code>SVector</code> of the underlying parameters used by the rotation representation.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">p = MRP(1.0, 2.0, 3.0)
Rotations.params(p) == @SVector [1.0, 2.0, 3.0]  # true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/Rotations.jl/blob/345d0d9b46dfca114c0adc1e17d43cf181a509ea/src/unitquaternion.jl#L223-L233">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rotations.perpendicular_vector-Tuple{StaticArrays.SVector{3}}" href="#Rotations.perpendicular_vector-Tuple{StaticArrays.SVector{3}}"><code>Rotations.perpendicular_vector</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">perpendicular_vector(vec)</code></pre><p>Compute a vector perpendicular to <code>vec</code> by switching the two elements with largest absolute value, flipping the sign of the second largest, and setting the remaining element to zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/Rotations.jl/blob/345d0d9b46dfca114c0adc1e17d43cf181a509ea/src/util.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rotations.principal_value-Tuple{Rotation}" href="#Rotations.principal_value-Tuple{Rotation}"><code>Rotations.principal_value</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">principal_value(R::Rotation{3})</code></pre><p><strong>Background:</strong> All non <code>RotMatrix</code> rotation types can represent the same <code>RotMatrix</code> in two or more ways. Sometimes a particular set of numbers is better conditioned (e.g. <code>MRP</code>) or obeys a particular convention (e.g. <code>AngleAxis</code> has non-negative rotation). In order to preserve differentiability it is necessary to allow rotation representations to travel slightly away from the nominal domain; this is critical for applications such as optimization or dynamics.</p><p>This function takes a rotation type (e.g. <code>QuatRotation</code>, <code>RotXY</code>) and outputs a new rotation of the same type that corresponds to the same <code>RotMatrix</code>, but that obeys certain conventions or is better conditioned. The outputs of the function have the following properties:</p><ul><li>all angles are between between <code>-pi</code> to <code>pi</code> (except for <code>AngleAxis</code> which is between <code>0</code> and <code>pi</code>).</li><li>all `QuatRotation have non-negative real part</li><li>the components of all <code>MRP</code> have a norm that is at most 1.</li><li>the <code>RotationVec</code> rotation is at most <code>pi</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/Rotations.jl/blob/345d0d9b46dfca114c0adc1e17d43cf181a509ea/src/principal_value.jl#L1-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rotations.pure_quaternion-Tuple{AbstractVector}" href="#Rotations.pure_quaternion-Tuple{AbstractVector}"><code>Rotations.pure_quaternion</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pure_quaternion(v::AbstractVector)
pure_quaternion(x, y, z)</code></pre><p>Create a <code>Quaternion</code> with zero scalar part (i.e. <code>q.q.s == 0</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/Rotations.jl/blob/345d0d9b46dfca114c0adc1e17d43cf181a509ea/src/unitquaternion.jl#L259-L264">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rotations.rmult-Tuple{QuatRotation}" href="#Rotations.rmult-Tuple{QuatRotation}"><code>Rotations.rmult</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rmult(q::QuatRotation)
rmult(q::StaticVector{4})</code></pre><p><code>rmult(q1)*params(q2)</code> return a vector equivalent to <code>q2*q1</code> (quaternion composition)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/Rotations.jl/blob/345d0d9b46dfca114c0adc1e17d43cf181a509ea/src/unitquaternion.jl#L409-L414">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rotations.rot_eltype-Tuple{Any}" href="#Rotations.rot_eltype-Tuple{Any}"><code>Rotations.rot_eltype</code></a> — <span class="docstring-category">Method</span></header><section><div><p>The element type for a rotation matrix with a given angle type is composed of trigonometric functions of that type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/Rotations.jl/blob/345d0d9b46dfca114c0adc1e17d43cf181a509ea/src/util.jl#L45-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rotations.rotation_between-Tuple{AbstractVector, AbstractVector}" href="#Rotations.rotation_between-Tuple{AbstractVector, AbstractVector}"><code>Rotations.rotation_between</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rotation_between(from, to)</code></pre><p>Compute the quaternion that rotates vector <code>from</code> so that it aligns with vector <code>to</code>, along the geodesic (shortest path).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/Rotations.jl/blob/345d0d9b46dfca114c0adc1e17d43cf181a509ea/src/unitquaternion.jl#L337-L342">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rotations.rotation_error-Tuple{Rotation, Rotation, Rotations.ErrorMap}" href="#Rotations.rotation_error-Tuple{Rotation, Rotation, Rotations.ErrorMap}"><code>Rotations.rotation_error</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rotation_error(R1::Rotation, R2::Rotation, error_map::ErrorMap)</code></pre><p>Compute the <code>RotationError</code> by calculating the &quot;difference&quot; between <code>R1</code> and <code>R2</code>, i.e. <code>R2\R1</code>, then mapped to a three-parameter error using <code>error_map</code>.</p><p>Can be equivalently called using the default map with <code>R1 ⊖ R2</code></p><p>If <code>error_map::IdentityMap</code>, then <code>SVector(R1\R2)::SVector{3}</code> is used as the error. Note this only works for three-parameter rotation representations such as <code>RodriguesParam</code> or <code>MRP</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/Rotations.jl/blob/345d0d9b46dfca114c0adc1e17d43cf181a509ea/src/rotation_error.jl#L32-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rotations.tmat-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T" href="#Rotations.tmat-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>Rotations.tmat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">tmat()</code></pre><p><code>tmat()*params(q)</code>return a vector equivalent to <code>inv(q)</code>, where <code>q</code> is a <code>QuatRotation</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/Rotations.jl/blob/345d0d9b46dfca114c0adc1e17d43cf181a509ea/src/unitquaternion.jl#L438-L442">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rotations.vmat-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T" href="#Rotations.vmat-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>Rotations.vmat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vmat()</code></pre><p><code>vmat()*params(q)</code><code>returns the imaginary     (vector) part of the quaternion</code>q<code>(equivalent to</code>vector(q)``)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/Rotations.jl/blob/345d0d9b46dfca114c0adc1e17d43cf181a509ea/src/unitquaternion.jl#L452-L457">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rotations.∇composition1-Tuple{QuatRotation, QuatRotation}" href="#Rotations.∇composition1-Tuple{QuatRotation, QuatRotation}"><code>Rotations.∇composition1</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">∇composition1(R2::Rotation{3}, R1::Rotation{3})</code></pre><p>Jacobian of <code>R2*R1</code> with respect to <code>R1</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/Rotations.jl/blob/345d0d9b46dfca114c0adc1e17d43cf181a509ea/src/unitquaternion.jl#L535-L539">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rotations.∇composition2-Tuple{QuatRotation, QuatRotation}" href="#Rotations.∇composition2-Tuple{QuatRotation, QuatRotation}"><code>Rotations.∇composition2</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">∇composition2(R2::Rotation{3}, R1::Rotation{3})</code></pre><p>Jacobian of <code>R2*R1</code> with respect to <code>R2</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/Rotations.jl/blob/345d0d9b46dfca114c0adc1e17d43cf181a509ea/src/unitquaternion.jl#L544-L548">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rotations.∇differential-Tuple{QuatRotation}" href="#Rotations.∇differential-Tuple{QuatRotation}"><code>Rotations.∇differential</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">∇differential(q::QuatRotation)</code></pre><p>Jacobian of <code>lmult(q) QuatMap(ϕ)</code>, when ϕ is near zero.</p><p>Useful for converting Jacobians from R⁴ to R³ and     correctly account for unit norm constraint. Jacobians for different     differential quaternion parameterization are the same up to a constant.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/Rotations.jl/blob/345d0d9b46dfca114c0adc1e17d43cf181a509ea/src/unitquaternion.jl#L490-L498">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rotations.∇err-Tuple{MRP, MRP}" href="#Rotations.∇err-Tuple{MRP, MRP}"><code>Rotations.∇err</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">∇err(p1::MRP, p2::MRP)</code></pre><p>Jacobian of <code>p1\p2</code> wrt <code>p2</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/Rotations.jl/blob/345d0d9b46dfca114c0adc1e17d43cf181a509ea/src/mrps.jl#L194-L198">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rotations.∇jacobian" href="#Rotations.∇jacobian"><code>Rotations.∇jacobian</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">∇jacobian(::InvErrorMap, q::QuatRotation, b::SVector{3})</code></pre><p>Jacobian of G(q)&#39;b, where G(q) = jacobian(::InvErrorMap, q),     b is a 3-element vector</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/Rotations.jl/blob/345d0d9b46dfca114c0adc1e17d43cf181a509ea/src/error_maps.jl#L254-L259">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rotations.∇rotate-Tuple{QuatRotation, AbstractVector}" href="#Rotations.∇rotate-Tuple{QuatRotation, AbstractVector}"><code>Rotations.∇rotate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">∇rotate(R::Rotation{3}, r::AbstractVector)</code></pre><p>Jacobian of <code>R*r</code> with respect to the rotation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/Rotations.jl/blob/345d0d9b46dfca114c0adc1e17d43cf181a509ea/src/unitquaternion.jl#L524-L528">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rotations.∇²differential-Tuple{QuatRotation, AbstractVector}" href="#Rotations.∇²differential-Tuple{QuatRotation, AbstractVector}"><code>Rotations.∇²differential</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">∇²differential(q::QuatRotation, b::AbstractVector)</code></pre><p>Jacobian of <code>(∂/∂ϕ lmult(q) QuatMap(ϕ))</code>b, evaluated at ϕ=0, and <code>b</code> has length 4.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/Rotations.jl/blob/345d0d9b46dfca114c0adc1e17d43cf181a509ea/src/unitquaternion.jl#L513-L517">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rotations.∇²err-Tuple{MRP, MRP, AbstractVector}" href="#Rotations.∇²err-Tuple{MRP, MRP, AbstractVector}"><code>Rotations.∇²err</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">∇²err(p1::MRP, p2::MRP, b::StaticVector{3})</code></pre><p>Jacobian of <code>(∂/∂p p1\p2)&#39;b</code> wrt <code>p2</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/Rotations.jl/blob/345d0d9b46dfca114c0adc1e17d43cf181a509ea/src/mrps.jl#L217-L221">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../visualizing/">« Visualizing Rotations</a><a class="docs-footer-nextpage" href="../reference/">References »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.12 on <span class="colophon-date" title="Thursday 17 February 2022 03:05">Thursday 17 February 2022</span>. Using Julia version 1.7.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
