var documenterSearchIndex = {"docs":
[{"location":"functionreference/","page":"Function Reference","title":"Function Reference","text":"Modules = [Rotations]","category":"page"},{"location":"functionreference/#Rotations.Angle2d","page":"Function Reference","title":"Rotations.Angle2d","text":"struct Angle2d{T} <: Rotation{2,T}\n    theta::T\nend\n\nA 2×2 rotation matrix parameterized by a 2D rotation by angle. Only the angle is stored inside the Angle2d type, values of getindex etc. are computed on the fly.\n\n\n\n\n\n","category":"type"},{"location":"functionreference/#Rotations.Angle2dGenerator","page":"Function Reference","title":"Rotations.Angle2dGenerator","text":"struct Angle2dGenerator{T} <: RotationGenerator{2,T}\n    v::T\nend\n\nA 2×2 rotation generator matrix (i.e. skew-symmetric matrix). [ 0 -v   v  0 ]\n\n\n\n\n\n","category":"type"},{"location":"functionreference/#Rotations.AngleAxis","page":"Function Reference","title":"Rotations.AngleAxis","text":"struct AngleAxis{T} <: Rotation{3,T}\nAngleAxis(Θ, x, y, z)\n\nA 3×3 rotation matrix parameterized by a 3D rotation by angle θ about an arbitrary axis [x, y, z].\n\nNote that the axis is not unique for θ = 0, and that this parameterization does not continuously map the neighbourhood of the null rotation (and therefore might not be suitable for autodifferentation and optimization purposes).\n\nNote: by default, the constructor will renormalize the input so that the axis has length 1 (x² + y² + z² = 1).\n\nRenormalization can be skipped by passing false as an additional constructor argument, in which case the user provides the guarantee that the input arguments represent a normalized rotation axis. Operations on an AngleAxis with a rotation axis that does not have unit norm, created by skipping renormalization in this fashion, are not guaranteed to do anything sensible.\n\n\n\n\n\n","category":"type"},{"location":"functionreference/#Rotations.ErrorMap","page":"Function Reference","title":"Rotations.ErrorMap","text":"ErrorMap\n\nA nonlinear mapping between the space of unit quaternions and three-dimensional rotation errors.\n\nThese mappings are extremely useful for converting from globally nonsingular 3D rotation representations such as QuatRotation or RotMatrix3 to a three-parameter error that can be efficiently used in gradient-based optimization methods that optimize deviations about a current iterate using first or second-order information.\n\nUsage\n\nerrmap(v::AbstractVector)  # \"forward\" map from a 3D error to a `QuatRotation`\ninv(errmap)(R::Rotation)   # \"inverse\" map from a rotation (via `QuatRotation`) to a 3D error\n\nwhere errmap <: ErrorMap\n\nImplemented Maps\n\nCayleyMap:  Uses RodriguesParam as the error representation (default).   Goes singular at 180° and does not have a sign ambiguity.\nExponentialMap: Uses the canonical exponential map from Lie Group theory. Computationally   expensive to compute. Exhibits kinematic singularities.\nMRPMap: Uses a scaled MRP as the error representation. Singular at 360° but has   a sign ambiguity (with the \"shadow\" MRP set).\nQuatVecMap: Uses the vector part of the quaternions. Cheapest map to compute, but   goes singular at 180° and suffers from sign ambiguity.\nIdentityMap: Maps values through directly. Only works with three-parameter rotation   representations with the following methods: R(::SVector{3}) and SVector(::R)::SVector{3}\n\n\n\n\n\n","category":"type"},{"location":"functionreference/#Rotations.InvErrorMap","page":"Function Reference","title":"Rotations.InvErrorMap","text":"InvErrorMap\n\nThe nonlinear mapping from unit quaternions to a three-dimensional error state. Obtained by inverting an ErrorMap, i.e.\n\nInvCayleyMap() = inv(CayleyMap())\n\nUsage\n\nimap(R::Rotation)             # \"inverse\" map from a rotation to a 3D error\ninv(imap)(v::AbstractVector)  # \"forward\" map from a 3D error to a `QuatRotation`\n\nwhere imap <: InvErrorMap.\n\nSee ErrorMap for documentation on the implemented maps.\n\n\n\n\n\n","category":"type"},{"location":"functionreference/#Rotations.MRP","page":"Function Reference","title":"Rotations.MRP","text":"MRP{T} <: Rotation\n\nModified Rodrigues Parameter. Is a 3D parameterization of attitude, and is a sterographic projection of the 4D unit sphere onto the plane tangent to the negative real pole. They have a singularity at θ = ±360°.\n\nConstructors\n\nMRP(x, y, z) MRP(r::AbstractVector)\n\n\n\n\n\n","category":"type"},{"location":"functionreference/#Rotations.QuatRotation","page":"Function Reference","title":"Rotations.QuatRotation","text":"QuatRotation{T} <: Rotation\n\n4-parameter attitute representation that is singularity-free. Quaternions with unit norm represent a double-cover of SO(3). The QuatRotation does NOT strictly enforce the unit norm constraint, but certain methods will assume you have a unit quaternion. Follows the Hamilton convention for quaternions.\n\nConstructors\n\nQuatRotation(w,x,y,z)\nQuatRotation(q::AbstractVector)\n\nwhere w is the scalar (real) part, x,y, and z are the vector (imaginary) part, and q = [w,x,y,z].\n\n\n\n\n\n","category":"type"},{"location":"functionreference/#Rotations.RodriguesParam","page":"Function Reference","title":"Rotations.RodriguesParam","text":"RodriguesParam{T}\n\nRodrigues parameters are a three-dimensional parameterization of rotations. They have a singularity at 180° but do not inherit the sign ambiguities of quaternions or MRPs\n\n\n\n\n\n","category":"type"},{"location":"functionreference/#Rotations.RotMatrix","page":"Function Reference","title":"Rotations.RotMatrix","text":"struct RotMatrix{N,T} <: Rotation{N,T}\n\nA statically-sized, N×N unitary (orthogonal) matrix.\n\nNote: the orthonormality of the input matrix is not checked by the constructor.\n\n\n\n\n\n","category":"type"},{"location":"functionreference/#Rotations.RotMatrixGenerator","page":"Function Reference","title":"Rotations.RotMatrixGenerator","text":"struct RotMatrixGenerator{N,T} <: RotationGenerator{N,T}\n\nA statically-sized, N×N skew-symmetric matrix.\n\nNote: the skew-symmetricity of the input matrix is not checked by the constructor.\n\n\n\n\n\n","category":"type"},{"location":"functionreference/#Rotations.RotX","page":"Function Reference","title":"Rotations.RotX","text":"struct RotX{T} <: Rotation{3,T}\nRotX(theta)\n\nA 3×3 rotation matrix which represents a rotation by theta about the X axis.\n\n\n\n\n\n","category":"type"},{"location":"functionreference/#Rotations.RotXY","page":"Function Reference","title":"Rotations.RotXY","text":"struct RotXY{T} <: Rotation{3,T}\nRotXY(theta_x, theta_y)\n\nA 3×3 rotation matrix which represents a rotation by theta_y about the Y axis, followed by a rotation by theta_x about the X axis.\n\n\n\n\n\n","category":"type"},{"location":"functionreference/#Rotations.RotXYX","page":"Function Reference","title":"Rotations.RotXYX","text":"struct RotXYX{T} <: Rotation{3,T}\nRotXYX(theta1, theta2, theta3)\n\nA 3×3 rotation matrix parameterized by the \"proper\" XYX Euler angle convention, consisting of first a rotation about the X axis by theta3, followed by a rotation about the Y axis by theta2, and finally a rotation about the X axis by theta1.\n\n\n\n\n\n","category":"type"},{"location":"functionreference/#Rotations.RotXYZ","page":"Function Reference","title":"Rotations.RotXYZ","text":"struct RotXYZ{T} <: Rotation{3,T}\nRotXYZ(theta1, theta2, theta3)\nRotXYZ(roll=r, pitch=p, yaw=y)\n\nA 3×3 rotation matrix parameterized by the \"Tait-Bryant\" XYZ Euler angle convention, consisting of first a rotation about the Z axis by theta3, followed by a rotation about the Y axis by theta2, and finally a rotation about the X axis by theta1.\n\nThe keyword argument form applies roll, pitch and yaw to the X, Y and Z axes respectively, in XYZ order. (Because it is a right-handed coordinate system, note that positive pitch is heading in the negative Z axis).\n\n\n\n\n\n","category":"type"},{"location":"functionreference/#Rotations.RotXZ","page":"Function Reference","title":"Rotations.RotXZ","text":"struct RotXZ{T} <: Rotation{3,T}\nRotXZ(theta_x, theta_z)\n\nA 3×3 rotation matrix which represents a rotation by theta_z about the Z axis, followed by a rotation by theta_x about the X axis.\n\n\n\n\n\n","category":"type"},{"location":"functionreference/#Rotations.RotXZX","page":"Function Reference","title":"Rotations.RotXZX","text":"struct RotXZX{T} <: Rotation{3,T}\nRotXZX(theta1, theta2, theta3)\n\nA 3×3 rotation matrix parameterized by the \"proper\" XZX Euler angle convention, consisting of first a rotation about the X axis by theta3, followed by a rotation about the Z axis by theta2, and finally a rotation about the X axis by theta1.\n\n\n\n\n\n","category":"type"},{"location":"functionreference/#Rotations.RotXZY","page":"Function Reference","title":"Rotations.RotXZY","text":"struct RotXZY{T} <: Rotation{3,T}\nRotXZY(theta1, theta2, theta3)\nRotXZY(roll=r, pitch=p, yaw=y)\n\nA 3×3 rotation matrix parameterized by the \"Tait-Bryant\" XZY Euler angle convention, consisting of first a rotation about the Y axis by theta3, followed by a rotation about the Z axis by theta2, and finally a rotation about the X axis by theta1.\n\nThe keyword argument form applies roll, pitch and yaw to the X, Y and Z axes respectively, in XZY order. (Because it is a right-handed coordinate system, note that positive pitch is heading in the negative Z axis).\n\n\n\n\n\n","category":"type"},{"location":"functionreference/#Rotations.RotY","page":"Function Reference","title":"Rotations.RotY","text":"struct RotY{T} <: Rotation{3,T}\nRotY(theta)\n\nA 3×3 rotation matrix which represents a rotation by theta about the Y axis.\n\n\n\n\n\n","category":"type"},{"location":"functionreference/#Rotations.RotYX","page":"Function Reference","title":"Rotations.RotYX","text":"struct RotYX{T} <: Rotation{3,T}\nRotYX(theta_y, theta_x)\n\nA 3×3 rotation matrix which represents a rotation by theta_x about the X axis, followed by a rotation by theta_y about the Y axis.\n\n\n\n\n\n","category":"type"},{"location":"functionreference/#Rotations.RotYXY","page":"Function Reference","title":"Rotations.RotYXY","text":"struct RotYXY{T} <: Rotation{3,T}\nRotYXY(theta1, theta2, theta3)\n\nA 3×3 rotation matrix parameterized by the \"proper\" YXY Euler angle convention, consisting of first a rotation about the Y axis by theta3, followed by a rotation about the X axis by theta2, and finally a rotation about the Y axis by theta1.\n\n\n\n\n\n","category":"type"},{"location":"functionreference/#Rotations.RotYXZ","page":"Function Reference","title":"Rotations.RotYXZ","text":"struct RotYXZ{T} <: Rotation{3,T}\nRotYXZ(theta1, theta2, theta3)\nRotYXZ(roll=r, pitch=p, yaw=y)\n\nA 3×3 rotation matrix parameterized by the \"Tait-Bryant\" YXZ Euler angle convention, consisting of first a rotation about the Z axis by theta3, followed by a rotation about the X axis by theta2, and finally a rotation about the Y axis by theta1.\n\nThe keyword argument form applies roll, pitch and yaw to the X, Y and Z axes respectively, in YXZ order. (Because it is a right-handed coordinate system, note that positive pitch is heading in the negative Z axis).\n\n\n\n\n\n","category":"type"},{"location":"functionreference/#Rotations.RotYZ","page":"Function Reference","title":"Rotations.RotYZ","text":"struct RotYZ{T} <: Rotation{3,T}\nRotYZ(theta_y, theta_z)\n\nA 3×3 rotation matrix which represents a rotation by theta_z about the Z axis, followed by a rotation by theta_y about the Y axis.\n\n\n\n\n\n","category":"type"},{"location":"functionreference/#Rotations.RotYZX","page":"Function Reference","title":"Rotations.RotYZX","text":"struct RotYZX{T} <: Rotation{3,T}\nRotYZX(theta1, theta2, theta3)\nRotYZX(roll=r, pitch=p, yaw=y)\n\nA 3×3 rotation matrix parameterized by the \"Tait-Bryant\" YZX Euler angle convention, consisting of first a rotation about the X axis by theta3, followed by a rotation about the Z axis by theta2, and finally a rotation about the Y axis by theta1.\n\nThe keyword argument form applies roll, pitch and yaw to the X, Y and Z axes respectively, in YZX order. (Because it is a right-handed coordinate system, note that positive pitch is heading in the negative Z axis).\n\n\n\n\n\n","category":"type"},{"location":"functionreference/#Rotations.RotYZY","page":"Function Reference","title":"Rotations.RotYZY","text":"struct RotYZY{T} <: Rotation{3,T}\nRotYZY(theta1, theta2, theta3)\n\nA 3×3 rotation matrix parameterized by the \"proper\" YXY Euler angle convention, consisting of first a rotation about the Y axis by theta3, followed by a rotation about the Z axis by theta2, and finally a rotation about the Y axis by theta1.\n\n\n\n\n\n","category":"type"},{"location":"functionreference/#Rotations.RotZ","page":"Function Reference","title":"Rotations.RotZ","text":"struct RotZ{T} <: Rotation{3,T}\nRotZ(theta)\n\nA 3×3 rotation matrix which represents a rotation by theta about the Z axis.\n\n\n\n\n\n","category":"type"},{"location":"functionreference/#Rotations.RotZX","page":"Function Reference","title":"Rotations.RotZX","text":"struct RotZX{T} <: Rotation{3,T}\nRotZX(theta_z, theta_x)\n\nA 3×3 rotation matrix which represents a rotation by theta_x about the X axis, followed by a rotation by theta_z about the Z axis.\n\n\n\n\n\n","category":"type"},{"location":"functionreference/#Rotations.RotZXY","page":"Function Reference","title":"Rotations.RotZXY","text":"struct RotZXY{T} <: Rotation{3,T}\nRotZXY(theta1, theta2, theta3)\nRotZXY(roll=r, pitch=p, yaw=y)\n\nA 3×3 rotation matrix parameterized by the \"Tait-Bryant\" ZXY Euler angle convention, consisting of first a rotation about the Y axis by theta3, followed by a rotation about the X axis by theta2, and finally a rotation about the Z axis by theta1.\n\nThe keyword argument form applies roll, pitch and yaw to the X, Y and Z axes respectively, in ZXY order. (Because it is a right-handed coordinate system, note that positive pitch is heading in the negative Z axis).\n\n\n\n\n\n","category":"type"},{"location":"functionreference/#Rotations.RotZXZ","page":"Function Reference","title":"Rotations.RotZXZ","text":"struct RotZXZ{T} <: Rotation{3,T}\nRotZXZ(theta1, theta2, theta3)\n\nA 3×3 rotation matrix parameterized by the \"proper\" ZXZ Euler angle convention, consisting of first a rotation about the Z axis by theta3, followed by a rotation about the X axis by theta2, and finally a rotation about the Z axis by theta1.\n\n\n\n\n\n","category":"type"},{"location":"functionreference/#Rotations.RotZY","page":"Function Reference","title":"Rotations.RotZY","text":"struct RotZY{T} <: Rotation{3,T}\nRotZY(theta_z, theta_y)\n\nA 3×3 rotation matrix which represents a rotation by theta_y about the Y axis, followed by a rotation by theta_z about the Z axis.\n\n\n\n\n\n","category":"type"},{"location":"functionreference/#Rotations.RotZYX","page":"Function Reference","title":"Rotations.RotZYX","text":"struct RotZYX{T} <: Rotation{3,T}\nRotZYX(theta1, theta2, theta3)\nRotZYX(roll=r, pitch=p, yaw=y)\n\nA 3×3 rotation matrix parameterized by the \"Tait-Bryant\" ZYX Euler angle convention, consisting of first a rotation about the X axis by theta3, followed by a rotation about the Y axis by theta2, and finally a rotation about the Z axis by theta1.\n\nThe keyword argument form applies roll, pitch and yaw to the X, Y and Z axes respectively, in ZYX order. (Because it is a right-handed coordinate system, note that positive pitch is heading in the negative Z axis).\n\n\n\n\n\n","category":"type"},{"location":"functionreference/#Rotations.RotZYZ","page":"Function Reference","title":"Rotations.RotZYZ","text":"struct RotZYZ{T} <: Rotation{3,T}\nRotZYZ(theta1, theta2, theta3)\n\nA 3×3 rotation matrix parameterized by the \"proper\" ZXZ Euler angle convention, consisting of first a rotation about the Z axis by theta3, followed by a rotation about the Y axis by theta2, and finally a rotation about the Z axis by theta1.\n\n\n\n\n\n","category":"type"},{"location":"functionreference/#Rotations.Rotation","page":"Function Reference","title":"Rotations.Rotation","text":"abstract type Rotation{N,T} <: StaticMatrix{N,N,T}\n\nAn abstract type representing N-dimensional rotations. More abstractly, they represent unitary (orthogonal) N×N matrices.\n\n\n\n\n\n","category":"type"},{"location":"functionreference/#Rotations.RotationError","page":"Function Reference","title":"Rotations.RotationError","text":"RotationError{T<:Real, D<:ErrorMap} <: StaticVector{3,T}\n\nA three-parameter rotation error, converted to/from a QuatRotation using the ErrorMap D.\n\nUsage\n\nA RotationError is typically created using one of the following methods\n\nrotation_error(R1::Rotation, R2::Rotation, error_map::ErrorMap)\nR1 ⊖ R2\n\nwhich compute the difference between the rotations R1 and R2 and convert the result to a 3D rotation error using error_map.\n\nThe error can be \"added\" back to a rotation using the inverse operation:\n\nadd_error(R1::Rotation, e::RotationError)\nR1::Rotation ⊕ e::RotationError\n\n\n\n\n\n","category":"type"},{"location":"functionreference/#Rotations.RotationGenerator","page":"Function Reference","title":"Rotations.RotationGenerator","text":"abstract type RotationGenerator{N,T} <: StaticMatrix{N,N,T}\n\nAn abstract type representing N-dimensional rotation generator. More abstractly, they represent skew-symmetric real N×N matrices.\n\n\n\n\n\n","category":"type"},{"location":"functionreference/#Rotations.RotationVec","page":"Function Reference","title":"Rotations.RotationVec","text":"struct RotationVec{T} <: Rotation{3,T}\nRotationVec(sx, sy, sz)\n\nRodrigues vector parameterization of a 3×3 rotation matrix. The direction of the vector [sx, sy, sz] defines the axis of rotation, and the rotation angle is given by its norm.\n\n\n\n\n\n","category":"type"},{"location":"functionreference/#Rotations.RotationVecGenerator","page":"Function Reference","title":"Rotations.RotationVecGenerator","text":"struct RotationVecGenerator{T} <: RotationGenerator{2,T}\n    x::T\n    y::T\n    z::T\nend\n\nA 3×3 rotation generator matrix (i.e. skew-symmetric matrix). [ 0 -z  y   z  0 -x  -y  x  0]\n\n\n\n\n\n","category":"type"},{"location":"functionreference/#Base.:*-Tuple{QuatRotation, QuatRotation}","page":"Function Reference","title":"Base.:*","text":"(*)(q::QuatRotation, w::QuatRotation)\n\nQuternion Composition\n\nEquivalent to\n\nlmult(q) * SVector(w)\nrmult(w) * SVector(q)\n\nSets the output mapping equal to the mapping of w\n\n\n\n\n\n","category":"method"},{"location":"functionreference/#Base.:*-Tuple{QuatRotation, StaticArrays.StaticVector}","page":"Function Reference","title":"Base.:*","text":"(*)(q::QuatRotation, r::StaticVector)\n\nRotate a vector\n\nEquivalent to hmat()' lmult(q) * rmult(q)' hmat() * r\n\n\n\n\n\n","category":"method"},{"location":"functionreference/#Rotations.add_error-Tuple{Rotation, Rotations.RotationError}","page":"Function Reference","title":"Rotations.add_error","text":"add_error(R1::Rotation, e::RotationError)\n\n\"Adds\" the rotation error e to the rotation R1 by converting e to a quaternion via its ErrorMap and then composing with R1.\n\nEquivalent to\n\nR1 ⊕ e\n\n\n\n\n\n","category":"method"},{"location":"functionreference/#Rotations.hmat-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Function Reference","title":"Rotations.hmat","text":"hmat()\nhmat(r::AbstractVector)\n\nhmat()*r or hmat(r) converts r into a pure quaternion, where r is 3-dimensional.\n\nhmat() == vmat()'\n\n\n\n\n\n","category":"method"},{"location":"functionreference/#Rotations.isrotation-Union{Tuple{AbstractMatrix{T}}, Tuple{T}, Tuple{AbstractMatrix{T}, Real}} where T","page":"Function Reference","title":"Rotations.isrotation","text":"isrotation(r)\nisrotation(r, tol)\n\nCheck whether r is a 2×2 or 3×3 rotation matrix, where r * r' is within tol of the identity matrix (using the Frobenius norm). tol defaults to 1000 * eps(float(eltype(r))) or zero(T) for integer T.\n\n\n\n\n\n","category":"method"},{"location":"functionreference/#Rotations.jacobian","page":"Function Reference","title":"Rotations.jacobian","text":"jacobian(::ErrorMap, ϕ)\n\nJacobian of the quaternion map that takes a three-dimensional vector ϕ and returns a     unit quaternion. Returns a 4x3 Static Matrix\n\nFor all the maps (except the IdentityMap) jacobian(::ErrorMap, zeros(3)) = [0; I] = Hmat()'\n\n\n\n\n\n","category":"function"},{"location":"functionreference/#Rotations.jacobian-2","page":"Function Reference","title":"Rotations.jacobian","text":"jacobian(::InvErrorMap, q::QuatRotation)\n\nJacobian of the inverse quaternion map, returning a 3×4 matrix. For all maps: jacobian(::InvErrorMap, QuatRotation(I)) = [0 I] = Hmat()'\n\n\n\n\n\n","category":"function"},{"location":"functionreference/#Rotations.jacobian-Tuple{Type{RotMatrix}, QuatRotation}","page":"Function Reference","title":"Rotations.jacobian","text":"jacobian(::Type{output_param}, R::input_param)\n\nReturns the jacobian for transforming from the input rotation parameterization to the output parameterization, centered at the value of R.\n\njacobian(R::rotation_type, X::AbstractVector)\n\nReturns the jacobian for rotating the vector X by R.\n\n\n\n\n\n","category":"method"},{"location":"functionreference/#Rotations.kinematics-Union{Tuple{Q}, Tuple{Q, AbstractVector}} where Q<:QuatRotation","page":"Function Reference","title":"Rotations.kinematics","text":"kinematics(R::Rotation{3}, ω::AbstractVector)\n\nThe time derivative of the rotation R, according to the definition\n\nR = lim_Δt  0 fracR(t + Δt) - R(t)Δt\n\nwhere ω is the angular velocity. This is equivalent to\n\nR = lim_Δt  0 fracR δR - RΔt\n\nwhere δR is some small rotation, parameterized by a small rotation δθ about an axis r, such that lim_Δt  0 fracδθ rΔt = ω\n\nThe kinematics are extremely useful when computing the dynamics of rigid bodies, since Ṙ = kinematics(R,ω) is the first-order ODE for the evolution of the attitude dynamics.\n\nSee \"Fundamentals of Spacecraft Attitude Determination and Control\" by Markley and Crassidis Sections 3.1-3.2 for more details.\n\n\n\n\n\n","category":"method"},{"location":"functionreference/#Rotations.lmult-Tuple{QuatRotation}","page":"Function Reference","title":"Rotations.lmult","text":"lmult(q::QuatRotation)\nlmult(q::StaticVector{4})\n\nlmult(q2)*params(q1) returns a vector equivalent to q2*q1 (quaternion composition)\n\n\n\n\n\n","category":"method"},{"location":"functionreference/#Rotations.nearest_rotation-Union{Tuple{StaticArrays.StaticMatrix{N, N}}, Tuple{N}} where N","page":"Function Reference","title":"Rotations.nearest_rotation","text":"nearest_rotation(M) -> RotMatrix\n\nGet the nearest special orthonormal matrix from given matrix M. See Wahba's problem for more information.\n\n\n\n\n\n","category":"method"},{"location":"functionreference/#Rotations.params-Tuple{QuatRotation}","page":"Function Reference","title":"Rotations.params","text":"params(R::Rotation)\n\nReturn an SVector of the underlying parameters used by the rotation representation.\n\nExample\n\np = MRP(1.0, 2.0, 3.0)\nRotations.params(p) == @SVector [1.0, 2.0, 3.0]  # true\n\n\n\n\n\n","category":"method"},{"location":"functionreference/#Rotations.perpendicular_vector-Tuple{StaticArrays.SVector{3}}","page":"Function Reference","title":"Rotations.perpendicular_vector","text":"perpendicular_vector(vec)\n\nCompute a vector perpendicular to vec by switching the two elements with largest absolute value, flipping the sign of the second largest, and setting the remaining element to zero.\n\n\n\n\n\n","category":"method"},{"location":"functionreference/#Rotations.principal_value-Tuple{Rotation}","page":"Function Reference","title":"Rotations.principal_value","text":"principal_value(R::Rotation{3})\n\nBackground: All non RotMatrix rotation types can represent the same RotMatrix in two or more ways. Sometimes a particular set of numbers is better conditioned (e.g. MRP) or obeys a particular convention (e.g. AngleAxis has non-negative rotation). In order to preserve differentiability it is necessary to allow rotation representations to travel slightly away from the nominal domain; this is critical for applications such as optimization or dynamics.\n\nThis function takes a rotation type (e.g. QuatRotation, RotXY) and outputs a new rotation of the same type that corresponds to the same RotMatrix, but that obeys certain conventions or is better conditioned. The outputs of the function have the following properties:\n\nall angles are between between -pi to pi (except for AngleAxis which is between 0 and pi).\nall `QuatRotation have non-negative real part\nthe components of all MRP have a norm that is at most 1.\nthe RotationVec rotation is at most pi\n\n\n\n\n\n","category":"method"},{"location":"functionreference/#Rotations.pure_quaternion-Tuple{AbstractVector}","page":"Function Reference","title":"Rotations.pure_quaternion","text":"pure_quaternion(v::AbstractVector)\npure_quaternion(x, y, z)\n\nCreate a Quaternion with zero scalar part (i.e. q.q.s == 0).\n\n\n\n\n\n","category":"method"},{"location":"functionreference/#Rotations.rmult-Tuple{QuatRotation}","page":"Function Reference","title":"Rotations.rmult","text":"rmult(q::QuatRotation)\nrmult(q::StaticVector{4})\n\nrmult(q1)*params(q2) return a vector equivalent to q2*q1 (quaternion composition)\n\n\n\n\n\n","category":"method"},{"location":"functionreference/#Rotations.rot_eltype-Tuple{Any}","page":"Function Reference","title":"Rotations.rot_eltype","text":"The element type for a rotation matrix with a given angle type is composed of trigonometric functions of that type.\n\n\n\n\n\n","category":"method"},{"location":"functionreference/#Rotations.rotation_between-Tuple{AbstractVector, AbstractVector}","page":"Function Reference","title":"Rotations.rotation_between","text":"rotation_between(from, to)\n\nCompute the quaternion that rotates vector from so that it aligns with vector to, along the geodesic (shortest path).\n\n\n\n\n\n","category":"method"},{"location":"functionreference/#Rotations.rotation_error-Tuple{Rotation, Rotation, Rotations.ErrorMap}","page":"Function Reference","title":"Rotations.rotation_error","text":"rotation_error(R1::Rotation, R2::Rotation, error_map::ErrorMap)\n\nCompute the RotationError by calculating the \"difference\" between R1 and R2, i.e. R2\\R1, then mapped to a three-parameter error using error_map.\n\nCan be equivalently called using the default map with R1 ⊖ R2\n\nIf error_map::IdentityMap, then SVector(R1\\R2)::SVector{3} is used as the error. Note this only works for three-parameter rotation representations such as RodriguesParam or MRP.\n\n\n\n\n\n","category":"method"},{"location":"functionreference/#Rotations.tmat-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Function Reference","title":"Rotations.tmat","text":"tmat()\n\ntmat()*params(q)return a vector equivalent to inv(q), where q is a QuatRotation\n\n\n\n\n\n","category":"method"},{"location":"functionreference/#Rotations.vmat-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Function Reference","title":"Rotations.vmat","text":"vmat()\n\nvmat()*params(q)returns the imaginary     (vector) part of the quaternionq(equivalent tovector(q)``)\n\n\n\n\n\n","category":"method"},{"location":"functionreference/#Rotations.∇composition1-Tuple{QuatRotation, QuatRotation}","page":"Function Reference","title":"Rotations.∇composition1","text":"∇composition1(R2::Rotation{3}, R1::Rotation{3})\n\nJacobian of R2*R1 with respect to R1\n\n\n\n\n\n","category":"method"},{"location":"functionreference/#Rotations.∇composition2-Tuple{QuatRotation, QuatRotation}","page":"Function Reference","title":"Rotations.∇composition2","text":"∇composition2(R2::Rotation{3}, R1::Rotation{3})\n\nJacobian of R2*R1 with respect to R2\n\n\n\n\n\n","category":"method"},{"location":"functionreference/#Rotations.∇differential-Tuple{QuatRotation}","page":"Function Reference","title":"Rotations.∇differential","text":"∇differential(q::QuatRotation)\n\nJacobian of lmult(q) QuatMap(ϕ), when ϕ is near zero.\n\nUseful for converting Jacobians from R⁴ to R³ and     correctly account for unit norm constraint. Jacobians for different     differential quaternion parameterization are the same up to a constant.\n\n\n\n\n\n","category":"method"},{"location":"functionreference/#Rotations.∇err-Tuple{MRP, MRP}","page":"Function Reference","title":"Rotations.∇err","text":"∇err(p1::MRP, p2::MRP)\n\nJacobian of p1\\p2 wrt p2\n\n\n\n\n\n","category":"method"},{"location":"functionreference/#Rotations.∇jacobian","page":"Function Reference","title":"Rotations.∇jacobian","text":"∇jacobian(::InvErrorMap, q::QuatRotation, b::SVector{3})\n\nJacobian of G(q)'b, where G(q) = jacobian(::InvErrorMap, q),     b is a 3-element vector\n\n\n\n\n\n","category":"function"},{"location":"functionreference/#Rotations.∇rotate-Tuple{QuatRotation, AbstractVector}","page":"Function Reference","title":"Rotations.∇rotate","text":"∇rotate(R::Rotation{3}, r::AbstractVector)\n\nJacobian of R*r with respect to the rotation\n\n\n\n\n\n","category":"method"},{"location":"functionreference/#Rotations.∇²differential-Tuple{QuatRotation, AbstractVector}","page":"Function Reference","title":"Rotations.∇²differential","text":"∇²differential(q::QuatRotation, b::AbstractVector)\n\nJacobian of (∂/∂ϕ lmult(q) QuatMap(ϕ))b, evaluated at ϕ=0, and b has length 4.\n\n\n\n\n\n","category":"method"},{"location":"functionreference/#Rotations.∇²err-Tuple{MRP, MRP, AbstractVector}","page":"Function Reference","title":"Rotations.∇²err","text":"∇²err(p1::MRP, p2::MRP, b::StaticVector{3})\n\nJacobian of (∂/∂p p1\\p2)'b wrt p2\n\n\n\n\n\n","category":"method"},{"location":"visualizing/#Visualizing-Rotation","page":"Visualizing Rotations","title":"Visualizing Rotation","text":"","category":"section"},{"location":"visualizing/","page":"Visualizing Rotations","title":"Visualizing Rotations","text":"In general, 3 times 3 matrix has 9 parameters, so it's hard to visualize a matrix as a point. However, the Lie group SO(3) and SU(2) are 3-dimensional space, and it is able to visualize its element as a point in our 3-dimensional space.","category":"page"},{"location":"visualizing/#using-MRP","page":"Visualizing Rotations","title":"using MRP","text":"","category":"section"},{"location":"visualizing/","page":"Visualizing Rotations","title":"Visualizing Rotations","text":"(TBW)","category":"page"},{"location":"visualizing/#using-RodriguesParam","page":"Visualizing Rotations","title":"using RodriguesParam","text":"","category":"section"},{"location":"visualizing/","page":"Visualizing Rotations","title":"Visualizing Rotations","text":"(TBW)","category":"page"},{"location":"visualizing/#using-RotationVec","page":"Visualizing Rotations","title":"using RotationVec","text":"","category":"section"},{"location":"visualizing/","page":"Visualizing Rotations","title":"Visualizing Rotations","text":"(TBW)","category":"page"},{"location":"functions/#Common-Methods-for-Rotations","page":"Common Methods for Rotations","title":"Common Methods for Rotations","text":"","category":"section"},{"location":"functions/#rotation_angle,-rotation_axis","page":"Common Methods for Rotations","title":"rotation_angle, rotation_axis","text":"","category":"section"},{"location":"functions/#D","page":"Common Methods for Rotations","title":"3D","text":"","category":"section"},{"location":"functions/","page":"Common Methods for Rotations","title":"Common Methods for Rotations","text":"A rotation matrix can be expressed with one rotation around an axis and angle. these function can calculate these values.","category":"page"},{"location":"functions/","page":"Common Methods for Rotations","title":"Common Methods for Rotations","text":"example","category":"page"},{"location":"functions/","page":"Common Methods for Rotations","title":"Common Methods for Rotations","text":"using Rotations","category":"page"},{"location":"functions/","page":"Common Methods for Rotations","title":"Common Methods for Rotations","text":"R = RotXYZ(2.4, -1.8, 0.5)\nθ = rotation_angle(R)\nn = rotation_axis(R)\n# These matrices are approximately equal.\nR ≈ AngleAxis(θ, n...)","category":"page"},{"location":"functions/#D-2","page":"Common Methods for Rotations","title":"2D","text":"","category":"section"},{"location":"functions/","page":"Common Methods for Rotations","title":"Common Methods for Rotations","text":"(TBW)","category":"page"},{"location":"functions/#Rotations.params","page":"Common Methods for Rotations","title":"Rotations.params","text":"","category":"section"},{"location":"functions/","page":"Common Methods for Rotations","title":"Common Methods for Rotations","text":"The parameters of the rotation can be obtained by Rotations.params.","category":"page"},{"location":"functions/","page":"Common Methods for Rotations","title":"Common Methods for Rotations","text":"example","category":"page"},{"location":"functions/","page":"Common Methods for Rotations","title":"Common Methods for Rotations","text":"using Rotations","category":"page"},{"location":"functions/","page":"Common Methods for Rotations","title":"Common Methods for Rotations","text":"R = one(RotMatrix{3})  # Identity matrix\nRotations.params(RotYZY(R))  # Proper Euler angles, (y,z,y)\nRotations.params(RotXYZ(R))  # Tait–Bryan angles, (y,z,y)\nRotations.params(AngleAxis(R))  # Rotation around an axis (theta, axis_x, axis_y, axis_z)\nRotations.params(RotationVec(R))  # Rotation vector (v_x, v_y, v_z)\nRotations.params(QuatRotation(R))  # Quaternion (w, x, y, z)\nRotations.params(RodriguesParam(R))  # Rodrigues Parameters (x, y, z)\nRotations.params(MRP(R))  # Modified Rodrigues Parameters (x, y, z)","category":"page"},{"location":"functions/#isrotation","page":"Common Methods for Rotations","title":"isrotation","text":"","category":"section"},{"location":"functions/","page":"Common Methods for Rotations","title":"Common Methods for Rotations","text":"Check the given matrix is rotation matrix.","category":"page"},{"location":"functions/","page":"Common Methods for Rotations","title":"Common Methods for Rotations","text":"example","category":"page"},{"location":"functions/","page":"Common Methods for Rotations","title":"Common Methods for Rotations","text":"(TBW)","category":"page"},{"location":"functions/#nearest_rotation","page":"Common Methods for Rotations","title":"nearest_rotation","text":"","category":"section"},{"location":"functions/","page":"Common Methods for Rotations","title":"Common Methods for Rotations","text":"using Rotations","category":"page"},{"location":"functions/","page":"Common Methods for Rotations","title":"Common Methods for Rotations","text":"Get the nearest special orthonormal matrix from given matrix M. The problem of finding the orthogonal matrix nearest to a given matrix is related to the Wahba's problem.","category":"page"},{"location":"functions/","page":"Common Methods for Rotations","title":"Common Methods for Rotations","text":"example","category":"page"},{"location":"functions/","page":"Common Methods for Rotations","title":"Common Methods for Rotations","text":"M = randn(3,3)  # Generate random matrix\nR = nearest_rotation(M)  # Find the nearest rotation matrix\nU, V = R\\M, M/R  # Polar decomposition of M\nU ≈ U'  # U is a symmetric matrix (The same for V)","category":"page"},{"location":"functions/#rand","page":"Common Methods for Rotations","title":"rand","text":"","category":"section"},{"location":"functions/","page":"Common Methods for Rotations","title":"Common Methods for Rotations","text":"using Rotations","category":"page"},{"location":"functions/#rand-for-SO(2)","page":"Common Methods for Rotations","title":"rand for SO(2)","text":"","category":"section"},{"location":"functions/","page":"Common Methods for Rotations","title":"Common Methods for Rotations","text":"The following types have the same algebraic structure as SO(2)","category":"page"},{"location":"functions/","page":"Common Methods for Rotations","title":"Common Methods for Rotations","text":"RotMatrix{2}\nAngle2d\nRotX\nRotY\nRotZ","category":"page"},{"location":"functions/","page":"Common Methods for Rotations","title":"Common Methods for Rotations","text":"The random distribution is based on Haar measure.","category":"page"},{"location":"functions/","page":"Common Methods for Rotations","title":"Common Methods for Rotations","text":"example","category":"page"},{"location":"functions/","page":"Common Methods for Rotations","title":"Common Methods for Rotations","text":"R = rand(Angle2d)","category":"page"},{"location":"functions/#rand-for-SO(3)","page":"Common Methods for Rotations","title":"rand for SO(3)","text":"","category":"section"},{"location":"functions/","page":"Common Methods for Rotations","title":"Common Methods for Rotations","text":"The following types have an algebraic structure that is homomorphic to SO(3).","category":"page"},{"location":"functions/","page":"Common Methods for Rotations","title":"Common Methods for Rotations","text":"RotMatrix{3}\nRotXYZ (and other Euler angles)\nAngleAxis\nRotationVec\nQuatRotation\nRodriguesParam\nMRP","category":"page"},{"location":"functions/","page":"Common Methods for Rotations","title":"Common Methods for Rotations","text":"example","category":"page"},{"location":"functions/","page":"Common Methods for Rotations","title":"Common Methods for Rotations","text":"R = rand(RotationVec)","category":"page"},{"location":"functions/","page":"Common Methods for Rotations","title":"Common Methods for Rotations","text":"The random distribution is based on Haar measure.","category":"page"},{"location":"functions/#rand-for-RotXY-and-etc.","page":"Common Methods for Rotations","title":"rand for RotXY and etc.","text":"","category":"section"},{"location":"functions/","page":"Common Methods for Rotations","title":"Common Methods for Rotations","text":"There also are methods for rand(::RotXY) and other 2-axis rotations.","category":"page"},{"location":"functions/","page":"Common Methods for Rotations","title":"Common Methods for Rotations","text":"example","category":"page"},{"location":"functions/","page":"Common Methods for Rotations","title":"Common Methods for Rotations","text":"R = rand(RotXY)","category":"page"},{"location":"functions/","page":"Common Methods for Rotations","title":"Common Methods for Rotations","text":"The random distribution is NOT based on Haar measure because the set of RotXY doesn't have group structure.","category":"page"},{"location":"functions/","page":"Common Methods for Rotations","title":"Common Methods for Rotations","text":"Note that:","category":"page"},{"location":"functions/","page":"Common Methods for Rotations","title":"Common Methods for Rotations","text":"rand(RotX) is same as RotX(2π*rand()).\nrand(RotXY) is same as RotXY(2π*rand(), 2π*rand()).\nrand(RotXYZ) is not same as RotXYZ(2π*rand(), 2π*rand(), 2π*rand()).\nBut rand(RotXYZ) is same as RotXYZ(rand(QuatRotation)).","category":"page"},{"location":"3d_euler/#D-Rotation-with-Euler-Angles","page":"Euler Angles","title":"3D Rotation with Euler Angles","text":"","category":"section"},{"location":"3d_euler/","page":"Euler Angles","title":"Euler Angles","text":"Euler angles are a way to represent a rotation matrix with three rotations around cardinal axes.","category":"page"},{"location":"3d_euler/","page":"Euler Angles","title":"Euler Angles","text":"In Rotations.jl, there are 12 concrete types for Euler angles.","category":"page"},{"location":"3d_euler/","page":"Euler Angles","title":"Euler Angles","text":"Proper Euler angles\nRotZXZ, RotXYX, RotYZY, RotZYZ, RotXZX, RotYXY\nTait–Bryan angles\nRotXYZ, RotYZX, RotZXY, RotXZY, RotZYX, RotYXZ","category":"page"},{"location":"3d_euler/","page":"Euler Angles","title":"Euler Angles","text":"In addition, Rotations.jl provides concrete types that represent rotations in one or two axes.","category":"page"},{"location":"3d_euler/","page":"Euler Angles","title":"Euler Angles","text":"one axis\nRotX, RotY, RotZ\ntwo axes\nRotXY, RotYZ, RotZX, RotXZ, RotZY, RotYX","category":"page"},{"location":"3d_euler/#Rotation-around-one-axis","page":"Euler Angles","title":"Rotation around one axis","text":"","category":"section"},{"location":"3d_euler/","page":"Euler Angles","title":"Euler Angles","text":"beginaligned\nR_x(alpha)\n= beginpmatrix\n1  0  0 \n0  cos(alpha)  -sin(alpha) \n0  sin(alpha)  cos(alpha) \nendpmatrix \nR_y(alpha)\n= beginpmatrix\ncos(alpha)  0  sin(alpha) \n0  1  0 \n-sin(alpha)  0  cos(alpha) \nendpmatrix \nR_z(alpha)\n= beginpmatrix\ncos(alpha)  -sin(alpha)  0\nsin(alpha)  cos(alpha)  0\n0  0  1\nendpmatrix\nendaligned","category":"page"},{"location":"3d_euler/","page":"Euler Angles","title":"Euler Angles","text":"example","category":"page"},{"location":"3d_euler/","page":"Euler Angles","title":"Euler Angles","text":"using Rotations","category":"page"},{"location":"3d_euler/","page":"Euler Angles","title":"Euler Angles","text":"Here's an example for RotZ:","category":"page"},{"location":"3d_euler/","page":"Euler Angles","title":"Euler Angles","text":"α = 1.2  # Rotation angle\nR = RotZ(α)\nQ = [cos(α) -sin(α) 0\n      sin(α)  cos(α) 0\n      0       0      1]\n# These matrices are equal\nR == Q","category":"page"},{"location":"3d_euler/","page":"Euler Angles","title":"Euler Angles","text":"And more examples for RotX and RotY:","category":"page"},{"location":"3d_euler/","page":"Euler Angles","title":"Euler Angles","text":"# These matrices are equal\nRotX(α) == [1 0       0\n            0 cos(α) -sin(α)\n            0 sin(α)  cos(α)]\n# These matrices are equal\nRotY(α) == [cos(α) 0 sin(α)\n            0      1 0\n           -sin(α) 0 cos(α)]","category":"page"},{"location":"3d_euler/#Rotation-around-two-axes","page":"Euler Angles","title":"Rotation around two axes","text":"","category":"section"},{"location":"3d_euler/","page":"Euler Angles","title":"Euler Angles","text":"beginaligned\nR_xy(alphabeta)\n= R_x(alpha)R_y(beta)\n R_yx(alphabeta)\n= R_y(alpha)R_x(beta) \n\nR_yz(alphabeta)\n= R_y(alpha)R_z(beta)\n R_zy(alphabeta)\n= R_z(alpha)R_y(beta) \n\nR_zx(alphabeta)\n= R_z(alpha)R_x(beta)\n R_xz(alphabeta)\n= R_x(alpha)R_z(beta)\nendaligned","category":"page"},{"location":"3d_euler/","page":"Euler Angles","title":"Euler Angles","text":"example","category":"page"},{"location":"3d_euler/","page":"Euler Angles","title":"Euler Angles","text":"using Rotations","category":"page"},{"location":"3d_euler/","page":"Euler Angles","title":"Euler Angles","text":"α, β = 1.2, 4.7  # Rotation angles\nRotX(α) * RotY(β)\nRotXY(α, β)\n# These matrices are equal\nRotX(α) * RotY(β) == RotXY(α, β)","category":"page"},{"location":"3d_euler/#Rotation-around-three-axes-(Euler-Angles)","page":"Euler Angles","title":"Rotation around three axes (Euler Angles)","text":"","category":"section"},{"location":"3d_euler/","page":"Euler Angles","title":"Euler Angles","text":"Proper Euler angles","category":"page"},{"location":"3d_euler/","page":"Euler Angles","title":"Euler Angles","text":"beginaligned\nR_xyx(alpha beta gamma) = R_x(alpha) R_y(beta) R_x(gamma)\n R_yxy(alpha beta gamma) = R_y(alpha) R_x(beta) R_y(gamma) \nR_yzy(alpha beta gamma) = R_y(alpha) R_z(beta) R_y(gamma)\n R_zyz(alpha beta gamma) = R_z(alpha) R_y(beta) R_z(gamma) \nR_zxz(alpha beta gamma) = R_z(alpha) R_x(beta) R_z(gamma)\n R_xzx(alpha beta gamma) = R_x(alpha) R_z(beta) R_x(gamma)\nendaligned","category":"page"},{"location":"3d_euler/","page":"Euler Angles","title":"Euler Angles","text":"Tait–Bryan angles","category":"page"},{"location":"3d_euler/","page":"Euler Angles","title":"Euler Angles","text":"beginaligned\nR_xyz(alpha beta gamma) = R_x(alpha) R_y(beta) R_z(gamma)\n R_yxz(alpha beta gamma) = R_y(alpha) R_x(beta) R_z(gamma) \nR_yzx(alpha beta gamma) = R_y(alpha) R_z(beta) R_x(gamma)\n R_zyx(alpha beta gamma) = R_z(alpha) R_y(beta) R_x(gamma) \nR_zxy(alpha beta gamma) = R_z(alpha) R_x(beta) R_y(gamma)\n R_xzy(alpha beta gamma) = R_x(alpha) R_z(beta) R_y(gamma)\nendaligned","category":"page"},{"location":"3d_euler/","page":"Euler Angles","title":"Euler Angles","text":"example","category":"page"},{"location":"3d_euler/","page":"Euler Angles","title":"Euler Angles","text":"using Rotations","category":"page"},{"location":"3d_euler/","page":"Euler Angles","title":"Euler Angles","text":"α, β, γ = 1.2, 4.7, -0.4  # Rotation angles\nRotYXZ(α, β, γ)\nRotY(α)*RotX(β)*RotZ(γ)\n# These matrices are equal\nRotYXZ(α, β, γ) == RotY(α)*RotX(β)*RotZ(γ)","category":"page"},{"location":"2d_angle/#D-Rotation-by-Angle","page":"Angle","title":"2D Rotation by Angle","text":"","category":"section"},{"location":"2d_angle/#Angle2d","page":"Angle","title":"Angle2d","text":"","category":"section"},{"location":"2d_angle/","page":"Angle","title":"Angle","text":"(TBW)","category":"page"},{"location":"2d_angle/","page":"Angle","title":"Angle","text":"example","category":"page"},{"location":"2d_angle/","page":"Angle","title":"Angle","text":"(TBW)","category":"page"},{"location":"2d_matrix/#D-Rotation-Matrix","page":"Matrix","title":"2D Rotation Matrix","text":"","category":"section"},{"location":"2d_matrix/","page":"Matrix","title":"Matrix","text":"An 2 times 2 rotation matrix storing the rotation. This is a simple wrapper for a StaticArrays SMatrix{2,2,T}. A rotation matrix R should have the property I = R R^top, but this isn't enforced by the constructor. On the other hand, all the types below are guaranteed to be \"proper\" rotations for all input parameters (equivalently: parity conserving, in SO(2), det(R) = 1, or a rotation without reflection).","category":"page"},{"location":"2d_matrix/#RotMatrix2","page":"Matrix","title":"RotMatrix2","text":"","category":"section"},{"location":"2d_matrix/","page":"Matrix","title":"Matrix","text":"(TBW)","category":"page"},{"location":"2d_matrix/","page":"Matrix","title":"Matrix","text":"example","category":"page"},{"location":"2d_matrix/","page":"Matrix","title":"Matrix","text":"(TBW)","category":"page"},{"location":"reference/#Reference-for-rotations","page":"Reference for rotations","title":"Reference for rotations","text":"","category":"section"},{"location":"reference/","page":"Reference for rotations","title":"Reference for rotations","text":"Quaternion (Wikipedia)\nQuaternions and 3d rotation, explained interactively (by 3Blue1Brown)","category":"page"},{"location":"3d_quaternion/#D-Rotation-with-Quaternion-and-Related-Parameters","page":"Quaternion and Related Parameters","title":"3D Rotation with Quaternion and Related Parameters","text":"","category":"section"},{"location":"3d_quaternion/","page":"Quaternion and Related Parameters","title":"Quaternion and Related Parameters","text":"using Rotations","category":"page"},{"location":"3d_quaternion/#QuatRotation","page":"Quaternion and Related Parameters","title":"QuatRotation","text":"","category":"section"},{"location":"3d_quaternion/","page":"Quaternion and Related Parameters","title":"Quaternion and Related Parameters","text":"A 3D rotation parameterized by a unit quaternion (versor). Note that the constructor will renormalize the quaternion to be a unit quaternion, and that although they follow the same multiplicative algebra as quaternions, it is better to think of QuatRotation as a 3 times 3 matrix rather than as a quaternion number.","category":"page"},{"location":"3d_quaternion/","page":"Quaternion and Related Parameters","title":"Quaternion and Related Parameters","text":"beginaligned\n    leftw_mathrmU + ix_mathrmU + jy_mathrmU + kz_mathrmU in mathbbH    x_mathrmU y_mathrmU z_mathrmU in mathbbR right\n    simeq S^3\nendaligned","category":"page"},{"location":"3d_quaternion/","page":"Quaternion and Related Parameters","title":"Quaternion and Related Parameters","text":"example","category":"page"},{"location":"3d_quaternion/","page":"Quaternion and Related Parameters","title":"Quaternion and Related Parameters","text":"one(QuatRotation)  # null rotation\nα, β, γ = 1.2, -0.8, 0.1;\nRotX(α) ≈ QuatRotation(cos(α/2),sin(α/2),0,0)  # These matrices are equal\nRotY(β) ≈ QuatRotation(cos(β/2),0,sin(β/2),0)  # These matrices are equal\nRotZ(γ) ≈ QuatRotation(cos(γ/2),0,0,sin(γ/2))  # These matrices are equal","category":"page"},{"location":"3d_quaternion/#RodriguesParam","page":"Quaternion and Related Parameters","title":"RodriguesParam","text":"","category":"section"},{"location":"3d_quaternion/","page":"Quaternion and Related Parameters","title":"Quaternion and Related Parameters","text":"A 3-parameter representation of 3D rotations that has a singularity at 180^circ. They can be interpreted as a projection of the unit quaternion onto the plane tangent to the quaternion identity. They are computationally efficient and do not have a sign ambiguity of unit quaternion.","category":"page"},{"location":"3d_quaternion/","page":"Quaternion and Related Parameters","title":"Quaternion and Related Parameters","text":"left\nbeginaligned\n    beginaligned\n    x_mathrmR = x_mathrmUw_mathrmU \n    y_mathrmR = y_mathrmUw_mathrmU \n    z_mathrmR = z_mathrmUw_mathrmU\n    endaligned\nendaligned\nright","category":"page"},{"location":"3d_quaternion/","page":"Quaternion and Related Parameters","title":"Quaternion and Related Parameters","text":"example","category":"page"},{"location":"3d_quaternion/","page":"Quaternion and Related Parameters","title":"Quaternion and Related Parameters","text":"one(RodriguesParam)  # null rotation\nα, β, γ = 1.2, -0.8, 0.1;\nRotX(α) ≈ RodriguesParam(tan(α/2),0,0)  # These matrices are equal\nRotY(β) ≈ RodriguesParam(0,tan(β/2),0)  # These matrices are equal\nRotZ(γ) ≈ RodriguesParam(0,0,tan(γ/2))  # These matrices are equal","category":"page"},{"location":"3d_quaternion/#MRP-(Modified-Rodrigues-Parameters)","page":"Quaternion and Related Parameters","title":"MRP (Modified Rodrigues Parameters)","text":"","category":"section"},{"location":"3d_quaternion/","page":"Quaternion and Related Parameters","title":"Quaternion and Related Parameters","text":"A 3D rotation encoded by the stereographic projection of a unit quaternion. This projection can be visualized as a pin hole camera, with the pin hole matching the quaternion -1+0i+0j+0k and the image plane containing the origin and having normal direction 1+0i+0j+0k. The \"null rotation\" Quaternion(1.0,0,0,0) then maps to the MRP(0,0,0)","category":"page"},{"location":"3d_quaternion/","page":"Quaternion and Related Parameters","title":"Quaternion and Related Parameters","text":"These are similar to the Rodrigues vector in that the axis direction is stored in an unnormalized form, and the rotation angle is encoded in the length of the axis. This type has the nice property that the derivatives of the rotation matrix w.r.t. the MRP parameters are rational functions, making the MRP type a good choice for differentiation / optimization.","category":"page"},{"location":"3d_quaternion/","page":"Quaternion and Related Parameters","title":"Quaternion and Related Parameters","text":"They are frequently used in aerospace applications since they are a 3-parameter representation whose singularity happens at 360^circ. In practice, the singularity can be avoided with some switching logic between one of two equivalent MRPs (obtained by projecting the negated quaternion).","category":"page"},{"location":"3d_quaternion/","page":"Quaternion and Related Parameters","title":"Quaternion and Related Parameters","text":"left\nbeginaligned\n    beginaligned\n    x_mathrmM = dfracx_mathrmUw_mathrmU-1 \n    y_mathrmM = dfracy_mathrmUw_mathrmU-1 \n    z_mathrmM = dfracz_mathrmUw_mathrmU-1\n    endaligned\nendaligned\nright","category":"page"},{"location":"3d_quaternion/","page":"Quaternion and Related Parameters","title":"Quaternion and Related Parameters","text":"example","category":"page"},{"location":"3d_quaternion/","page":"Quaternion and Related Parameters","title":"Quaternion and Related Parameters","text":"one(MRP)  # null rotation\nα, β, γ = 1.2, -0.8, 0.1;\nRotX(α) ≈ MRP(sin(α/2)/(cos(α/2)-1),0,0)  # These matrices are equal\nRotY(β) ≈ MRP(0,sin(β/2)/(cos(β/2)-1),0)  # These matrices are equal\nRotZ(γ) ≈ MRP(0,0,sin(γ/2)/(cos(γ/2)-1))  # These matrices are equal","category":"page"},{"location":"3d_matrix/#D-Rotation-Matrix","page":"Matrix","title":"3D Rotation Matrix","text":"","category":"section"},{"location":"3d_matrix/","page":"Matrix","title":"Matrix","text":"An 3 times 3 rotation matrix storing the rotation. This is a simple wrapper for a StaticArrays SMatrix{3,3,T}. A rotation matrix R should have the property I = R R^top, but this isn't enforced by the constructor. On the other hand, all the types below are guaranteed to be \"proper\" rotations for all input parameters (equivalently: parity conserving, in SO(3), det(R) = 1, or a rotation without reflection).","category":"page"},{"location":"3d_matrix/#RotMatrix3","page":"Matrix","title":"RotMatrix3","text":"","category":"section"},{"location":"3d_matrix/","page":"Matrix","title":"Matrix","text":"example","category":"page"},{"location":"3d_matrix/","page":"Matrix","title":"Matrix","text":"(TBW)","category":"page"},{"location":"3d_angleaxis/#D-Rotation-around-an-axis","page":"Angle and Axis","title":"3D Rotation around an axis","text":"","category":"section"},{"location":"3d_angleaxis/","page":"Angle and Axis","title":"Angle and Axis","text":"In Rotations.jl, there are two concrete types to represent a rotation with given an axis and an angle.","category":"page"},{"location":"3d_angleaxis/","page":"Angle and Axis","title":"Angle and Axis","text":"AngleAxis\nRotationVec","category":"page"},{"location":"3d_angleaxis/#AngleAxis","page":"Angle and Axis","title":"AngleAxis","text":"","category":"section"},{"location":"3d_angleaxis/","page":"Angle and Axis","title":"Angle and Axis","text":"A 3D rotation with fields theta, axis_x, axis_y, and axis_z to store the rotation angle and axis of the rotation. Like all other types in this package, once it is constructed it acts and behaves as a 3×3 AbstractMatrix. The axis will be automatically renormalized by the constructor to be a unit vector, so that theta always represents the rotation angle in radians.","category":"page"},{"location":"3d_angleaxis/","page":"Angle and Axis","title":"Angle and Axis","text":"beginaligned\nR_bmn (theta)\n= exp(theta K(bmn)) \n= I + (sintheta) K(bmn)  +  (1-costheta) K^2(bmn) \n= beginpmatrix\ncostheta + n_x^2 (1-costheta)  n_xn_y (1-costheta) - n_z sintheta  n_zn_x (1-costheta) + n_y sintheta \nn_xn_y (1-costheta) + n_z sintheta  costheta + n_y^2 (1-costheta)  n_yn_z (1-costheta) - n_x sintheta \nn_zn_x (1-costheta) - n_y sintheta  n_yn_z (1-costheta) + n_x sintheta  costheta + n_z^2 (1-costheta)\nendpmatrix \n\nK(bmn)\n= beginpmatrix\n0     -n_z  n_y \nn_z   0     -n_x \n-n_y  n_x   0\nendpmatrix \n\nbmn\n= beginpmatrix\nn_x \nn_y \nn_z\nendpmatrix\n\nquad left(bmn= 1right)\nendaligned","category":"page"},{"location":"3d_angleaxis/","page":"Angle and Axis","title":"Angle and Axis","text":"example","category":"page"},{"location":"3d_angleaxis/","page":"Angle and Axis","title":"Angle and Axis","text":"using Rotations, LinearAlgebra\n# 1/3 (120°) rotation around the (1/√3, 1/√3, 1/√3) vector\nR = AngleAxis(2π/3, 1/√3, 1/√3, 1/√3)\n# This matrix swaps the xyz coordinates\nR * [1,2,3]\nR^2\nR^3\n# These matrices are approximately equal\nR^3 ≈ I(3)","category":"page"},{"location":"3d_angleaxis/#RotationVec","page":"Angle and Axis","title":"RotationVec","text":"","category":"section"},{"location":"3d_angleaxis/","page":"Angle and Axis","title":"Angle and Axis","text":"A 3D rotation encoded by an angle-axis representation as angle * axis. This type is used in packages such as OpenCV.","category":"page"},{"location":"3d_angleaxis/","page":"Angle and Axis","title":"Angle and Axis","text":"beginaligned\nR(bmv)\n= R_bmn (theta)  left(bmn = fracbmvbmv theta = bmv right)\nendaligned","category":"page"},{"location":"3d_angleaxis/","page":"Angle and Axis","title":"Angle and Axis","text":"note: Differentiation\nIf you're differentiating a Rodrigues Vector check the result is what you expect at theta = 0. The first derivative of the rotation should behave, but higher-order derivatives of it (as well as parameterization conversions) should be tested. The Stereographic Quaternion Projection (MRP) is the recommended three parameter format for differentiation.","category":"page"},{"location":"3d_angleaxis/","page":"Angle and Axis","title":"Angle and Axis","text":"example","category":"page"},{"location":"3d_angleaxis/","page":"Angle and Axis","title":"Angle and Axis","text":"using Rotations, LinearAlgebra\n# 1/3 (120°) rotation around the (1/√3, 1/√3, 1/√3) vector\nR = R = RotationVec(2π/3(√3), 2π/3(√3), 2π/3(√3))\n# This matrix swaps the xyz coordinates\nR * [1,2,3]\nR^2\nR^3\n# These matrices are approximately equal\nR^3 ≈ I(3)\n\nα, β, γ = 1.2, -0.8, 0.1;\nRotX(α) ≈ RotationVec(α,0,0)  # These matrices are equal\nRotY(β) ≈ RotationVec(0,β,0)  # These matrices are equal\nRotZ(γ) ≈ RotationVec(0,0,γ)  # These matrices are equal","category":"page"},{"location":"rotation_types/#Types-in-Rotations.jl","page":"Rotation Types","title":"Types in Rotations.jl","text":"","category":"section"},{"location":"rotation_types/#Abstract-rotations","page":"Rotation Types","title":"Abstract rotations","text":"","category":"section"},{"location":"rotation_types/","page":"Rotation Types","title":"Rotation Types","text":"A matrix R is called rotation matrix if R satisfies","category":"page"},{"location":"rotation_types/","page":"Rotation Types","title":"Rotation Types","text":"beginaligned\nR^top = R^-1  det(R)=1\nendaligned","category":"page"},{"location":"rotation_types/","page":"Rotation Types","title":"Rotation Types","text":"In Rotations.jl, there's an abstract type for rotations matrix, Rotation{L}. Where L is a size of the rotation matrix.","category":"page"},{"location":"rotation_types/#Type-hierarchy","page":"Rotation Types","title":"Type hierarchy","text":"","category":"section"},{"location":"rotation_types/","page":"Rotation Types","title":"Rotation Types","text":"using InteractiveUtils","category":"page"},{"location":"rotation_types/","page":"Rotation Types","title":"Rotation Types","text":"using Rotations, StaticArrays\nRotation <: StaticMatrix <: AbstractMatrix\nsubtypes(Rotation{2})\nsubtypes(Rotation{3})","category":"page"},{"location":"rotation_types/#Overview-of-each-type","page":"Rotation Types","title":"Overview of each type","text":"","category":"section"},{"location":"rotation_types/","page":"Rotation Types","title":"Rotation Types","text":"For more information, see the sidebar page.","category":"page"},{"location":"rotation_types/#D-rotations","page":"Rotation Types","title":"2D rotations","text":"","category":"section"},{"location":"rotation_types/","page":"Rotation Types","title":"Rotation Types","text":"RotMatrix2{T}\nRotation matrix in 2 dimensional Euclidean space.\nAngle2d\nParametrized with rotational angle.","category":"page"},{"location":"rotation_types/#D-rotations-2","page":"Rotation Types","title":"3D rotations","text":"","category":"section"},{"location":"rotation_types/","page":"Rotation Types","title":"Rotation Types","text":"RotMatrix3{T}\nRotation matrix in 3 dimensional Euclidean space.\nRotX, RotYZ, RotXYZ and etc.\nEuler angles.\nAngleAxis\nRotation around given axis and angle.\nRotationVec\nRotation around given axis. The length of axis vector represents its angle.\nQuatRotation\nA 3D rotation parameterized by a unit quaternion.\nMRP\nA 3D rotation encoded by the stereographic projection of a unit quaternion.","category":"page"},{"location":"#Rotations","page":"Home","title":"Rotations","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"3D rotations made easy in Julia","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: Documentation\nThe documentation is still work in progress. For more information, see alsoREADME in the repository\nTests in the repository(TBW) comments are left in areas that have not yet been documented. Feel free to open pull requests and improve this document!","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"pkg> add Rotations","category":"page"},{"location":"#First-example","page":"Home","title":"First example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Rotations\n\n# 3D Rotation by Euler Angles\nR_euler = RotXYZ(1,2,3)\n\n# Get an angle and an axis of the rotation\nrotation_angle(R_euler), rotation_axis(R_euler)\n\n# Convert the rotation to unit quaternion\nR_quat = QuatRotation(R_euler)\n\n# Get quaternion parameters of the rotation\nRotations.params(R_quat)\n\n# Convert the rotation to MRP (Modified Rodrigues Parameters)\nR_mrp = MRP(R_euler)\nRotations.params(R_mrp)\n\n# Get parameters of the MRP\nRotations.params(R_mrp)\n\n# Also supports 2D rotation\nR_2d = Angle2d(π/6)\n\n# Also supports some differentiation\nRotations.jacobian(RotMatrix, R_quat)","category":"page"}]
}
